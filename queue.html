<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QUEUE</title>
    <style>
            /* General reset */
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }

    body {
        font-family: Arial, sans-serif;
        background-color: #f4f4f4; /* Same background color */
        color: #33334d; /* Dark text color */
    }

    .container {
        display: flex;
        min-height: 100vh;
    }

    /* Navigation Bar (on the left side) */
    .navbar {
        width: 250px;
        background-color: #33334d; /* Preferred dark color */
        padding: 20px;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        overflow-y: auto;
        position: fixed; /* Keep navbar fixed to the left */
        height: 100vh; /* Full height to fill the left side */
    }

    .navlist {
        list-style: none;
        padding: 0;
    }

    .navlist li {
        margin: 10px 0;
    }

    .navlist a {
        text-decoration: none;
        color: #ceb040; /* Gold text */
        font-weight: bold;
        font-size: 18px;
        padding: 10px;
        display: block;
        transition: background-color 0.3s ease;
    }

    .navlist a:hover {
        background-color: #6d5c6a; /* Soft purple hover effect */
        color: #f4f4f4;
    }

    /* Main content */
    .main-content {
        flex-grow: 1;
        padding: 20px;
        display: flex;
        justify-content: center;
        align-items: flex-start;
    }

    .box-main {
        max-width: 800px;
        margin-left: 170px;
        width: 100%;
        background-color: #fff; /* White background for the box */
        padding: 20px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        border: 2px solid #ceb040; /* Gold border */
    }

    .firsthalf2 ul {
        list-style: none;
    }

    .firsthalf2 li {
        margin: 10px 0;
    }

    .firsthalf2 a {
        text-decoration: none;
        font-size: 16px;
        color: #6d5c6a;
        font-family:'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif;
        /* Soft purple color */
    }

    .firsthalf2 a:hover {
        color: #ceb040; /* Gold on hover */
    }
    .vasu {
            color: rgb(14, 13, 13);
            margin-left: 300px;
            max-width: 1000px;
            font-size: large;
            width: auto;
            background-color: #fff;
            /* White background for the box */
            padding: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            border: 4px solid #ceb040;
            word-wrap: break-word;
        }
        .vasu pre {
            word-wrap: break-word;
            white-space: pre-wrap;
            overflow-x: auto;
            padding: 10px;
            margin-bottom: 20px;
        }


        .vasu b {
            font-family: Arial, Helvetica, sans-serif;
            color: #ceb040;
        }

        .out {
            color: #fff;
            background-color: #111111;
        }
        .back-to-top {
            position: fixed;
            bottom: 20px;
            right: 10px;
            background-color: #ceb040;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 10px 15px;
            cursor: pointer;
            display: none; /* Hidden by default */
            z-index: 1000; /* On top of other elements */
        }

        .back-to-top:hover {
            background-color: #6d5c6a;
        }
    </style>
</head>

<body>
    <div class="container">
        <!-- Left Navigation Bar -->
        <nav class="navbar">
            <ul class="navlist">
                <li><a href="index.html">Home</a></li>
                <li><a href="2Darray.html">2D Array</a></li>
                <li><a href="graph.html">Graph</a></li>
                <li><a href="linkedlist.html">Linked List</a></li>
                <li><a href="queue.html">Queue</a></li>
                <li><a href="rec.html">Recursion</a></li>
                <li><a href="searching.html">Searching Algorithm</a></li>
                <li><a href="array.html">Single Dimension Array</a></li>
                <li><a href="sorting.html">Sorting Algorithm</a></li>
                <li><a href="stack.html">Stack</a></li>
                <li><a href="String.html">Strings</a></li>
                <li><a href="tree.html">Tree</a></li>
            </ul>
        </nav>

        <!-- Right Main Content -->
        <section class="main-content">
            <div class="box-main">
                <h1>Queue Operations:</h1> <!-- Added a heading for context -->
                <div class="firsthalf2">
                    <ul>
                        <li><a href="#qu1">1.IMPLEMENT THE OPERATIONS OF SIMPLE QUEUE IN AN INTEGER ARRAY (INSERT,
                                DELETE, PEEK, ISEMPTY, ISFULL)</a></li>
                        <li><a href="#qu2">2.IMPLEMENT THE OPERATIONS OF SIMPLE QUEUE IN A STRING ARRAY (INSERT,
                                DELETE, PEEK, ISEMPTY, ISFULL)</a></li>
                        <li><a href="#qu3">3.IMPLEMENT THE OPERATIONS OF QUEUE DYNAMICALLY OF INTEGERS (INSERT,
                                DELETE, PEEK, ISEMPTY, ISFULL)</a></li>
                        <li><a href="#qu4">4.IMPLEMENT THE OPERATIONS OF QUEUE DYNAMICALLY OF STRING (INSERT,
                                DELETE, PEEK, ISEMPTY, ISFULL)</a></li>
                        <li><a href="#qu5">5.IMPLEMENT THE OPERATIONS OF CIRCULAR QUEUE IN AN INTEGER ARRAY
                                (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</a></li>
                        <li><a href="#qu6">6.IMPLEMENT THE OPERATIONS OF CIRCULAR QUEUE IN A STRING ARRAY (INSERT,
                                DELETE, PEEK, ISEMPTY, ISFULL)</a></li>
                        <li><a href="#qu7">7.IMPLEMENT THE OPERATIONS OF PRIORITY QUEUE IN AN INTEGER ARRAY
                                (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</a></li>
                        <li><a href="#qu8">8.IMPLEMENT THE OPERATIONS OF PRIORITY QUEUE IN A STRING ARRAY (INSERT,
                                DELETE, PEEK, ISEMPTY, ISFULL)</a></li>
                        <li><a href="#qu9">9.IMPLEMENT THE OPERATIONS OF DOUBLE ENDED QUEUE IN AN INTEGER ARRAY
                                (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</a></li>
                        <li><a href="#qu10">10.IMPLEMENT THE OPERATIONS OF DOUBLE ENDED QUEUE IN A STRING ARRAY
                                (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</a></li>
                        <li><a href="#qu11">11.IMPLEMENT THE OPERATIONS OF PRIORITY QUEUE DYNAMICALLY OF INTEGERS
                                (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</a></li>
                        <li><a href="#qu12">12.IMPLEMENT THE OPERATIONS OF PRIORITY QUEUE DYNAMICALLY OF STRING
                                (INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</a></li>
                        <li><a href="#qu13">13. Find the first circular tour that visits all petrol pumps.

                                <br> Explanation - <br>

                                Given information about N petrol pumps (say arr[]) that are present in a circular path.
                                The information consists of the distance of the next petrol pump from the current one
                                (in arr[i][1]) and the amount of petrol stored in that petrol pump (in arr[i][0]).
                                Consider a truck with infinite capacity that consumes 1 unit of petrol to travel 1 unit
                                distance. The task is to find the index of the first starting point such that the truck
                                can visit all the petrol pumps and come back to that starting point. Note: Return -1 if
                                no such tour exists. Examples: Input: arr[] = {{4, 6}, {6, 5}, {7, 3}, {4, 5}}. Output:
                                1 Explanation: If started from 1st index then a circular tour can be covered. Input:
                                arr[] {{6, 4}, {3, 6}, {7, 3}} Output: 2</a></li>
                        <li><a href="#qu14">14. Length of the longest valid substring.

                                <br>Explanation - <br>

                                Given a string consisting of opening and closing parenthesis, find the length of the
                                longest valid parenthesis substring. Examples: Input : ((() Output : 2 Explanation : ()
                                Input: )()()) Output : 4 Explanation: ()() Input: ()(())))) Output: 6 Explanation:
                                ()(())</a></li>
                        <li><a href="#qu15">15. Find the Next Greater Element

                                <br>Explanation - <br>

                                Given an array arr[ ] of size N having elements, the task is to find the next greater
                                element for each element of the array in order of their appearance in the array. Next
                                greater element of an element in the array is the nearest element on the right which is
                                greater than the current element. If there does not exist next greater of current
                                element, then next greater element for current element is -1. For example, next greater
                                of the last element is always -1. Example 1: Input: N = 4, arr[] = [1 3 2 4] Output: 3 4
                                4 -1 Explanation: In the array, the next larger element to 1 is 3 , 3 is 4 , 2 is 4 and
                                for 4 ? since it doesn't exist, it is -1. Example 2: Input: N = 5, arr[] [6 8 0 1 3]
                                Output: 8 -1 1 3 -1 Explanation: In the array, the next larger element to 6 is 8, for 8
                                there is no larger elements hence it is -1, for 0 it is 1 , for 1 it is 3 and then for 3
                                there is no larger element on right and hence -1.</a></li>
                        <li><a href="#qu16">16. Find Next Smaller Element.

                                <br> Explanation - <br>

                                Given an array, print the Next Smaller Element (NSE) for every element. The NSE for an
                                element x is the first smaller element on the right side of x in the array. Elements for
                                which no smaller element exist (on the right side), consider NSE as -1. Examples: Input:
                                [4, 8, 5, 2, 25] Output: [2, 5, 2, -1, -1] Explanation: The first element smaller than 4
                                having index > 0 is 2. The first element smaller than 8 having index > 1 is 5. The first
                                element smaller than 5 having index > 2 is 2. There are no elements smaller than 4
                                having index > 3. There are no elements smaller than 4 having index > 4. Input: [13, 7,
                                6, 12] Output: [7, 6, -1, -1] Explanation: The first element smaller than 13 having
                                index > 0 is 7. The first element smaller than 7 having index > 1 is 6. There are no
                                elements smaller than 6 having index > 2. There are no elements smaller than 12 having
                                index > 3.</a></li>
                        <li><a href="#qu17">17. Queue based approach for first non-repeating character in a stream.

                                <br> Explanation - <br>

                                Given a stream of characters and we have to find first non repeating character each time
                                a character is inserted to the stream. Examples: Input : a a b c Output : a -1 b b Input
                                : a a c Output : a -1 c</a></li>
                        <li><a href="#qu18">18. Reverse First K elements of Queue

                                <br>Explanation - <br>

                                Given an integer K and a queue of integers, we need to reverse the order of the first K
                                elements of the queue, leaving the other elements in the same relative order. Only
                                following standard operations are allowed on queue. enqueue(x) : Add an item x to rear
                                of queue dequeue() : Remove an item from front of queue size() : Returns number of
                                elements in queue. front() : Finds front item. Note: The above operations represent the
                                general processings. In-built functions of the respective languages can be used to solve
                                the problem. Example 1: Input: 5 3 1 2 3 4 5 Output: 3 2 1 4 5 Explanation: After
                                reversing the given input from the 3rd position the resultant output will be 3 2 1 4 5.
                                Example 2: Input: 4 4 4 3 2 1 Output: 1 2 3 4 Explanation: After reversing the given
                                input from the 4th position the resultant output will be 1 2 3 4.</a></li>
                        <li><a href="#qu19">19. Queue Reversal

                                <br> Explanation - <br>

                                Given a Queue Q containing N elements. The task is to reverse the Queue. Your task is to
                                complete the function rev(), that reverses the N elements of the queue. Example 1:
                                Input: 6 4 3 1 10 2 6 Output: 6 2 10 1 3 4 Explanation: After reversing the given
                                elements of the queue , the resultant queue will be 6 2 10 1 3 4. Example 2: Input: 4 4
                                3 2 1 Output: 1 2 3 4 Explanation: After reversing the given elements of the queue , the
                                resultant queue will be 1 2 3 4.</a></li>
                        <li><a href="#qu20">20. Rotten Oranges

                               <br> Explanation - <br>

                                Given a grid of dimension nxm where each cell in the grid can have values 0, 1 or 2
                                which has the following meaning: 0 : Empty cell 1 : Cells have fresh oranges 2 : Cells
                                have rotten oranges We have to determine what is the earliest time after which all the
                                oranges are rotten. A rotten orange at index [i,j] can rot other fresh orange at indexes
                                [i-1,j], [i+1,j], [i,j-1], [i,j+1] (up, down, left and right) in unit time. Example 1:
                                Input: grid = {{0,1,2},{0,1,2},{2,1,1}} Output: 1 Explanation: The grid is- 0 1 2 0 1 2
                                2 1 1 Oranges at positions (0,2), (1,2), (2,0) will rot oranges at (0,1), (1,1), (2,2)
                                and (2,1) in unit time. Example 2: Input: grid = {{2,2,0,1}} Output: -1 Explanation: The
                                grid is- 2 2 0 1 Oranges at (0,0) and (0,1) can't rot orange at (0,3).</a></li>
                    </ul>
                </div>
            </div>
        </section>
    </div>
    <div class="vasu">
<pre>
<br>
<b id="qu1">1.IMPLEMENT THE OPERATIONS OF SIMPLE QUEUE IN AN INTEGER ARRAY (INSERT,
DELETE, PEEK, ISEMPTY, ISFULL)</b>

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int front = -1;
int rear = -1;

void push(int *queue, int size) {
    int item;
    if (rear == size - 1) {
        printf("The queue is full.\n");
        return;
    }

    printf("Enter the item: ");
    scanf("%d", &item);

    if (front == -1 && rear == -1) {
        front++;
        rear++;
    } else {
        rear++;
    }
    queue[rear] = item;
    printf("Item pushed %d at rear = %d, front = %d\n", queue[rear], rear, front);
}

void pop(int *queue, int size) {
    if (front == -1 && rear == -1) {
        printf("The queue is empty.\n");
        return;
    }

    printf("Item popped %d at front = %d, rear = %d\n", queue[front], front, rear);

    if (front == rear) {
        // Reset the queue pointers if it's now empty
        front = -1;
        rear = -1;
    } else {
        front++;
    }
    printf("Current front = %d, rear = %d\n", front, rear);
}

void peek(int *queue, int size) {
    if (front == -1 && rear == -1) {
        printf("The queue is empty.\n");
    } else {
        printf("Front element: %d\n", queue[front]);
    }
}

void isempty() {
    if (front == -1 && rear == -1) {
        printf("The queue is empty.\n");
    } else {
        printf("The queue is not empty.\n");
    }
}

void isfull(int size) {
    if (rear == size - 1) {
        printf("The queue is full.\n");
    } else {
        printf("The queue is not full.\n");
    }
}

int main() {
    int choice;
    int queue[5];  // Queue array without initialization

    printf("\nEnter 1 for push()");
    printf("\nEnter 2 for pop()");
    printf("\nEnter 3 for peek()");
    printf("\nEnter 4 for isempty()");
    printf("\nEnter 5 for isfull()");
    printf("\nEnter 6 to exit\n");

    while (1) {
        printf("\nEnter your choice: ");
        scanf("%d", &choice);
        switch (choice) {
            case 1:
                push(queue, 5);
                break;
            case 2:
                pop(queue, 5);
                break;
            case 3:
                peek(queue, 5);
                break;
            case 4:
                isempty();
                break;
            case 5:
                isfull(5);
                break;
            case 6:
                exit(0);
            default:
                printf("INVALID INPUT\n");
                break;
        }
    }

    return 0;
}


</pre>
<pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>
Enter 1 for push()
Enter 2 for pop()
Enter 3 for peek()
Enter 4 for isempty()
Enter 5 for isfull()
Enter 6 to exit

Enter your choice: 1
Enter the item: 10
Item pushed 10 at rear = 0, front = 0

Enter your choice: 1
Enter the item: 20
Item pushed 20 at rear = 1, front = 0

Enter your choice: 3
Front element: 10

Enter your choice: 2
Item popped 10 at front = 0, rear = 1
Current front = 1, rear = 1

Enter your choice: 4
The queue is not empty.

Enter your choice: 5
The queue is not full.

Enter your choice: 2
Item popped 20 at front = 1, rear = 1
Current front = -1, rear = -1

Enter your choice: 4
The queue is empty.

Enter your choice: 6


</pre>

<pre>
<br>
<b id="qu2">2.IMPLEMENT THE OPERATIONS OF SIMPLE QUEUE IN A STRING ARRAY (INSERT,
DELETE, PEEK, ISEMPTY, ISFULL)</b>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int front = -1;
int rear = -1;

void push(char queue[][50], int size) {
    if (rear == size - 1) {
        printf("The queue is full.\n");
        return;
    }

    char item[50];
    printf("Enter the string: ");
    scanf("%s", item);

    if (front == -1 && rear == -1) {
        front++;
        rear++;
    } else {
        rear++;
    }

    strcpy(queue[rear], item); 
    printf("Item pushed '%s' at rear = %d, front = %d\n", queue[rear], rear, front);
}

void pop(char queue[][50], int size) {
    if (front == -1 && rear == -1) {
        printf("The queue is empty.\n");
        return;
    }

    printf("Item popped '%s' at front = %d, rear = %d\n", queue[front], front, rear);

    if (front == rear) {
        front = -1;
        rear = -1;
    } else {
        front++;
    }
    printf("Current front = %d, rear = %d\n", front, rear);
}

void peek(char queue[][50], int size) {
    if (front == -1 && rear == -1) {
        printf("The queue is empty.\n");
    } else {
        printf("Front element: '%s'\n", queue[front]);
    }
}

void isempty() {
    if (front == -1 && rear == -1) {
        printf("The queue is empty.\n");
    } else {
        printf("The queue is not empty.\n");
    }
}

void isfull(int size) {
    if (rear == size - 1) {
        printf("The queue is full.\n");
    } else {
        printf("The queue is not full.\n");
    }
}

int main() {
    int choice;
    char queue[5][50]; 

    printf("\nEnter 1 for push()");
    printf("\nEnter 2 for pop()");
    printf("\nEnter 3 for peek()");
    printf("\nEnter 4 for isempty()");
    printf("\nEnter 5 for isfull()");
    printf("\nEnter 6 to exit\n");

    while (1) {
        printf("\nEnter your choice: ");
        scanf("%d", &choice);
        switch (choice) {
            case 1:
                push(queue, 5);
                break;
            case 2:
                pop(queue, 5);
                break;
            case 3:
                peek(queue, 5);
                break;
            case 4:
                isempty();
                break;
            case 5:
                isfull(5);
                break;
            case 6:
                exit(0);
            default:
                printf("INVALID INPUT\n");
                break;
        }
    }

    return 0;
}


</pre>
<pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>
Enter 1 for push()
Enter 2 for pop()
Enter 3 for peek()
Enter 4 for isempty()
Enter 5 for isfull()
Enter 6 to exit

Enter your choice: 1
Enter the string: hello
Item pushed 'hello' at rear = 0, front = 0

Enter your choice: 1
Enter the string: world
Item pushed 'world' at rear = 1, front = 0

Enter your choice: 3
Front element: 'hello'

Enter your choice: 2
Item popped 'hello' at front = 0, rear = 1
Current front = 1, rear = 1

Enter your choice: 4
The queue is not empty.

Enter your choice: 5
The queue is not full.

Enter your choice: 2
Item popped 'world' at front = 1, rear = 1
Current front = -1, rear = -1

Enter your choice: 4
The queue is empty.

Enter your choice: 6


</pre>

<pre>
<br>
<b id="qu3">3.IMPLEMENT THE OPERATIONS OF QUEUE DYNAMICALLY OF INTEGERS (INSERT,
DELETE, PEEK, ISEMPTY, ISFULL)</b>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct Queue {
    int max;
    int *array;
    int front;
    int rear;
};

struct Queue q1;

void init() {
    printf(&quot;\nEnter the max (size of the queue): &quot;);
    scanf(&quot;%d&quot;, &amp;q1.max);
    q1.array = (int *)malloc(sizeof(int) * q1.max);
    q1.front = q1.rear = -1;
}

int isFull() {
    return q1.rear == q1.max - 1;
}

int isEmpty() {
    return q1.front == -1 || q1.front &gt; q1.rear;
}

void insert() {
    if (isFull()) {
        printf(&quot;Overflow! Cannot push!&quot;\n);
        return;
    }

    int item;
    printf(&quot;Enter the item: &quot;);
    scanf(&quot;%d&quot;, &amp;item);

    if (isEmpty()) {
        q1.front = 0;
    }
    q1.rear++;
    q1.array[q1.rear] = item;
    printf(&quot;Item is pushed!&quot;\n);
}

void delete() {
    if (isEmpty()) {
        printf(&quot;Underflow! Cannot pop!&quot;\n);
        return;
    }

    int item = q1.array[q1.front];
    printf(&quot;Item %d is popped!&quot;, item);
    q1.front++;

    if (q1.front &gt; q1.rear) { 
        q1.front = q1.rear = -1;
    }
}

int peek() {
    if (isEmpty()) {
        printf(&quot;Queue is empty!&quot;\n);
        return -1;
    }
    return q1.array[q1.front];
}

void traverse() {
    if (isEmpty()) {
        printf(&quot;Queue is empty!&quot;\n);
        return;
    }

    printf(&quot;Queue elements: &quot;);
    for (int i = q1.front; i &lt;= q1.rear; i++) {
        printf(&quot;%d\t&quot;, q1.array[i]);
    }
    printf(&quot;\n&quot;);
}

int main() {
    int choice;
    printf(&quot;\n1. Initialize Queue&quot;);
    printf(&quot;\n2. Insert&quot;);
    printf(&quot;\n3. Delete&quot;);
    printf(&quot;\n4. Peek&quot;);
    printf(&quot;\n5. Traverse&quot;);
    printf(&quot;\n6. Exit&quot;);
    while (1) {
    printf(&quot;\nEnter your choice: &quot;);
    scanf(&quot;%d&quot;, &amp;choice);
        switch (choice) {
            case 1:
                init();
                break;
            case 2:
                insert();
                break;
            case 3:
                delete();
                break;
            case 4: {
                int item = peek();
                if (item != -1) {
                    printf(&quot;Front item: %d\n&quot;, item);
                }
                break;
            }
            case 5:
                traverse();
                break;
            case 6:
                free(q1.array);
                exit(0);
            default:
                printf(&quot;Invalid choice!&quot;\n);
        }
    }
    return 0;
}

</pre>
<pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>
Enter the max (size of the queue): 5

1. Initialize Queue
2. Insert
3. Delete
4. Peek
5. Traverse
6. Exit
Enter your choice: 1

Enter the max (size of the queue): 5

Enter your choice: 2
Enter the item: 10
Item is pushed!

Enter your choice: 2
Enter the item: 20
Item is pushed!

Enter your choice: 5
Queue elements: 10    20    

Enter your choice: 4
Front item: 10

Enter your choice: 3
Item 10 is popped!

Enter your choice: 5
Queue elements: 20  
</pre>

<pre>
<br>
<b id="qu4">4.IMPLEMENT THE OPERATIONS OF QUEUE DYNAMICALLY OF STRING (INSERT,
DELETE, PEEK, ISEMPTY, ISFULL)</b>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

struct Queue {
    int max;
    char **array;
    int front;
    int rear;
};

struct Queue q1;

void init() {
    printf(&quot;\nEnter the max (size of the queue): &quot;);
    scanf(&quot;%d&quot;, &amp;q1.max);
    q1.array = (char **)malloc(sizeof(char *) * q1.max);
    for (int i = 0; i &lt; q1.max; i++) {
        q1.array[i] = (char *)malloc(sizeof(char) * 100);
    }
    q1.front = q1.rear = -1;
}

int isFull() {
    return q1.rear == q1.max - 1;
}

int isEmpty() {
    return q1.front == -1 || q1.front &gt; q1.rear;
}

void insert() {
    if (isFull()) {
        printf(&quot;Overflow! Cannot push!&quot;\n);
        return;
    }

    char item[100];
    printf(&quot;Enter the item: &quot;);
    scanf(&quot;%s&quot;, item);

    if (isEmpty()) {
        q1.front = 0;
    }
    q1.rear++;
    strcpy(q1.array[q1.rear], item);
    printf(&quot;Item is pushed!&quot;\n);
}

void delete() {
    if (isEmpty()) {
        printf(&quot;Underflow! Cannot pop!&quot;\n);
        return;
    }

    printf(&quot;Item '%s' is popped!&quot;, q1.array[q1.front]);
    q1.front++;

    if (q1.front &gt; q1.rear) { 
        q1.front = q1.rear = -1;
    }
}

char* peek() {
    if (isEmpty()) {
        printf(&quot;Queue is empty!&quot;\n);
        return NULL;
    }
    return q1.array[q1.front];
}

void traverse() {
    if (isEmpty()) {
        printf(&quot;Queue is empty!&quot;\n);
        return;
    }

    printf(&quot;Queue elements: &quot;);
    for (int i = q1.front; i &lt;= q1.rear; i++) {
        printf(&quot;%s\t&quot;, q1.array[i]);
    }
    printf(&quot;\n&quot;);
}

int main() {
    int choice;
    printf(&quot;\n1. Initialize Queue&quot;);
    printf(&quot;\n2. Insert&quot;);
    printf(&quot;\n3. Delete&quot;);
    printf(&quot;\n4. Peek&quot;);
    printf(&quot;\n5. Traverse&quot;);
    printf(&quot;\n6. Exit&quot;);
    while (1) {
        printf(&quot;\nEnter your choice: &quot;);
        scanf(&quot;%d&quot;, &amp;choice);
        switch (choice) {
            case 1:
                init();
                break;
            case 2:
                insert();
                break;
            case 3:
                delete();
                break;
            case 4: {
                char* item = peek();
                if (item != NULL) {
                    printf(&quot;Front item: %s\n&quot;, item);
                }
                break;
            }
            case 5:
                traverse();
                break;
            case 6:
                for (int i = 0; i &lt; q1.max; i++) {
                    free(q1.array[i]);
                }
                free(q1.array);
                exit(0);
            default:
                printf(&quot;Invalid choice!&quot;\n);
        }
    }
    return 0;
}                 
</pre>
<pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>
Enter the max (size of the queue): 5

1. Initialize Queue
2. Insert
3. Delete
4. Peek
5. Traverse
6. Exit

Enter your choice: 1

Enter your choice: 2
Enter the item: Hello
Item is pushed!

Enter your choice: 2
Enter the item: World
Item is pushed!

Enter your choice: 5
Queue elements: Hello    World    

Enter your choice: 4
Front item: Hello

Enter your choice: 3
Item 'Hello' is popped!

Enter your choice: 5
Queue elements: World    

Enter your choice: 6

</pre>

<pre>
<br>
<b id="qu5">5.IMPLEMENT THE OPERATIONS OF CIRCULAR QUEUE IN AN INTEGER ARRAY
(INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</b>  

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int front = -1;
int rear = -1;
int queue[5];  

void push() {
    int item;
    if ((front == 0 && rear == 5 - 1) || (front > 0 && rear == front - 1)) {
        printf("The queue is full.\n");
        return;
    }

    printf("Enter the item: ");
    scanf("%d", &item);

    if (front == -1 && rear == -1) {
        front = rear = 0;
    } else if (rear == 5 - 1 && front > 0) {
        rear = 0;  
    } else {
        rear++;
    }

    queue[rear] = item;
    printf("Item pushed %d at rear = %d, front = %d\n", queue[rear], rear, front);
}

void pop() {
    if (front == -1) {
        printf("The queue is empty.\n");
        return;
    }

    printf("Item popped %d at front = %d, rear = %d\n", queue[front], front, rear);
    queue[front] = 0;  

    if (front == rear) {
        front = rear = -1;  
    } else if (front == 5 - 1) {
        front = 0;  
    } else {
        front++;
    }
    printf("Current front = %d, rear = %d\n", front, rear);
}

void peek() {
    if (front == -1) {
        printf("The queue is empty.\n");
    } else {
        printf("Front element: %d\n", queue[front]);
    }
}

void isempty() {
    if (front == -1) {
        printf("The queue is empty.\n");
    } else {
        printf("The queue is not empty.\n");
    }
}

void isfull() {
    if ((front == 0 && rear == 5 - 1) || (front > 0 && rear == front - 1)) {
        printf("The queue is full.\n");
    } else {
        printf("The queue is not full.\n");
    }
}

int main() {
    int choice;
    printf("\n1. Push (Insert)");
    printf("\n2. Pop (Delete)");
    printf("\n3. Peek (Front Element)");
    printf("\n4. Check if Empty");
    printf("\n5. Check if Full");
    printf("\n6. Exit");
    while (1) {
        printf("\nEnter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                push();
                break;
            case 2:
                pop();
                break;
            case 3:
                peek();
                break;
            case 4:
                isempty();
                break;
            case 5:
                isfull();
                break;
            case 6:
                exit(0);
            default:
                printf("INVALID INPUT\n");
                break;
        }
    }

    return 0;
}


</pre>
<pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>

1. Push (Insert)
2. Pop (Delete)
3. Peek (Front Element)
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 1
Enter the item: 10
Item pushed 10 at rear = 0, front = 0

Enter your choice: 1
Enter the item: 20
Item pushed 20 at rear = 1, front = 0

Enter your choice: 1
Enter the item: 30
Item pushed 30 at rear = 2, front = 0

Enter your choice: 1
Enter the item: 40
Item pushed 40 at rear = 3, front = 0

Enter your choice: 1
Enter the item: 50
Item pushed 50 at rear = 4, front = 0

Enter your choice: 1
The queue is full.

Enter your choice: 2
Item popped 10 at front = 0, rear = 4
Current front = 1, rear = 4

Enter your choice: 3
Front element: 20

Enter your choice: 4
The queue is not empty.

Enter your choice: 5
The queue is full.

Enter your choice: 2
Item popped 20 at front = 1, rear = 4
Current front = 2, rear = 4

Enter your choice: 2
Item popped 30 at front = 2, rear = 4
Current front = 3, rear = 4

Enter your choice: 2
Item popped 40 at front = 3, rear = 4
Current front = 4, rear = 4

Enter your choice: 2
Item popped 50 at front = 4, rear = 4
Current front = -1, rear = -1

Enter your choice: 4
The queue is empty.


Enter your choice: 6


</pre>

<pre>
<br>
<b id="qu6">6.IMPLEMENT THE OPERATIONS OF CIRCULAR QUEUE IN A STRING ARRAY (INSERT,
DELETE, PEEK, ISEMPTY, ISFULL)</b>

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define MAX_SIZE 5

char queue[MAX_SIZE][50];
int front = -1, rear = -1;

int isFull() {
    return (front == 0 && rear == MAX_SIZE - 1) || (front == rear + 1);
}

int isEmpty() {
    return front == -1;
}

void insert(char item[]) {
    if (isFull()) {
        printf("Queue is full. Cannot insert %s.\n", item);
    } else {
        if (front == -1) {
            front = rear = 0;
        } else if (rear == MAX_SIZE - 1) {
            rear = 0;
        } else {
            rear++;
        }
        strcpy(queue[rear], item);
        printf("Inserted \"%s\" into the queue.\n", item);
    }
}

void delete() {
    if (isEmpty()) {
        printf("Queue is empty. Cannot delete.\n");
    } else {
        char item[50];
        strcpy(item, queue[front]);
        if (front == rear) {
            front = rear = -1;
        } else if (front == MAX_SIZE - 1) {
            front = 0;
        } else {
            front++;
        }
        printf("Deleted \"%s\" from the queue.\n", item);
    }
}

void peek() {
    if (isEmpty()) {
        printf("Queue is empty. No element to peek.\n");
    } else {
        printf("Front element: \"%s\"\n", queue[front]);
    }
}

int main() {
    int choice;
    char item[50];

    printf("Circular Queue Operations:\n");
    printf("1. Insert\n");
    printf("2. Delete\n");
    printf("3. Peek\n");
    printf("4. Is Empty\n");
    printf("5. Is Full\n");
    printf("6. Exit\n");
    
    while (1) {
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter a string to insert: ");
                scanf("%s", item);
                insert(item);
                break;

            case 2:
                delete();
                break;

            case 3:
                peek();
                break;

            case 4:
                if (isEmpty()) {
                    printf("Queue is empty.\n");
                } else {
                    printf("Queue is not empty.\n");
                }
                break;

            case 5:
                if (isFull()) {
                    printf("Queue is full.\n");
                } else {
                    printf("Queue is not full.\n");
                }
                break;

            case 6:
                exit(0);
                break;

            default:
                printf("Invalid choice. Please enter a valid option.\n");
        }
    }

    return 0;
}


</pre>
<pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>

Circular Queue Operations:
1. Insert
2. Delete
3. Peek
4. Is Empty
5. Is Full
6. Exit
Enter your choice: 1
Enter a string to insert: Apple
Inserted "Apple" into the queue.

Enter your choice: 1
Enter a string to insert: Banana
Inserted "Banana" into the queue.

Enter your choice: 1
Enter a string to insert: Cherry
Inserted "Cherry" into the queue.

Enter your choice: 1
Enter a string to insert: Date
Inserted "Date" into the queue.

Enter your choice: 1
Enter a string to insert: Elderberry
Inserted "Elderberry" into the queue.

Enter your choice: 1
Enter a string to insert: Fig
Queue is full. Cannot insert Fig.

Enter your choice: 3
Front element: "Apple"

Enter your choice: 2
Deleted "Apple" from the queue.

Enter your choice: 3
Front element: "Banana"

Enter your choice: 4
Queue is not empty.

Enter your choice: 5
Queue is not full.

Enter your choice: 2
Deleted "Banana" from the queue.

Enter your choice: 2
Deleted "Cherry" from the queue.

Enter your choice: 2
Deleted "Date" from the queue.

Enter your choice: 2
Deleted "Elderberry" from the queue.

Enter your choice: 2
Queue is empty. Cannot delete.

Enter your choice: 4
Queue is empty.

Enter your choice: 6

</pre>


<pre>
<br>
<b id="qu7">7.IMPLEMENT THE OPERATIONS OF PRIORITY QUEUE IN AN INTEGER ARRAY
(INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</b> 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define MAX_SIZE 5

int priorityQueue[MAX_SIZE];
int size = 0;

int isFull() {
    return size == MAX_SIZE;
}

int isEmpty() {
    return size == 0;
}

void insert(int element) {
    if (isFull()) {
        printf("Priority Queue is full. Cannot insert %d.\n", element);
        return;
    }

    int i;
    for (i = size - 1; (i >= 0 && priorityQueue[i] < element); i--) {
        priorityQueue[i + 1] = priorityQueue[i];
    }
    priorityQueue[i + 1] = element;
    size++;
    printf("Inserted %d into the priority queue.\n", element);
}

void delete() {
    if (isEmpty()) {
        printf("Priority Queue is empty. Cannot delete.\n");
        return;
    }
    int deletedElement = priorityQueue[0];
    for (int i = 0; i < size - 1; i++) {
        priorityQueue[i] = priorityQueue[i + 1];
    }
    size--;
    printf("Deleted %d from the priority queue.\n", deletedElement);
}

void peek() {
    if (isEmpty()) {
        printf("Priority Queue is empty. No element to peek.\n");
    } else {
        printf("Highest priority element: %d\n", priorityQueue[0]);
    }
}

int main() {
    int choice, value;
    printf("\nPriority Queue Operations:\n");
    printf("1. Insert\n");
    printf("2. Delete\n");
    printf("3. Peek\n");
    printf("4. Is Empty\n");
    printf("5. Is Full\n");
    printf("6. Exit\n");
    while (1) {
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter an integer to insert: ");
                scanf("%d", &value);
                insert(value);
                break;
            case 2:
                delete();
                break;
            case 3:
                peek();
                break;
            case 4:
                if (isEmpty()) {
                    printf("Priority Queue is empty.\n");
                } else {
                    printf("Priority Queue is not empty.\n");
                }
                break;
            case 5:
                if (isFull()) {
                    printf("Priority Queue is full.\n");
                } else {
                    printf("Priority Queue is not full.\n");
                }
                break;
            case 6:
                exit(0);
            default:
                printf("Invalid choice. Please enter a valid option.\n");
        }
    }

    return 0;
}


</pre>
<pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>
Priority Queue Operations:
1. Insert
2. Delete
3. Peek
4. Is Empty
5. Is Full
6. Exit
Enter your choice: 1
Enter an integer to insert: 10
Inserted 10 into the priority queue.

Enter your choice: 1
Enter an integer to insert: 20
Inserted 20 into the priority queue.


Enter your choice: 1
Enter an integer to insert: 15
Inserted 15 into the priority queue.


Enter your choice: 1
Enter an integer to insert: 25
Inserted 25 into the priority queue.


Enter your choice: 1
Enter an integer to insert: 5
Inserted 5 into the priority queue.


Enter your choice: 1
Enter an integer to insert: 30
Priority Queue is full. Cannot insert 30.


Enter your choice: 3
Highest priority element: 25


Enter your choice: 2
Deleted 25 from the priority queue.


Enter your choice: 3
Highest priority element: 20


Enter your choice: 4
Priority Queue is not empty.

Enter your choice: 5
Priority Queue is not full.


Enter your choice: 2
Deleted 20 from the priority queue.


Enter your choice: 2
Deleted 15 from the priority queue.


Enter your choice: 2
Deleted 10 from the priority queue.

Enter your choice: 2
Priority Queue is empty. Cannot delete.

Enter your choice: 6

</pre>

<pre>
<br>
<b id="qu8">8.IMPLEMENT THE OPERATIONS OF PRIORITY QUEUE IN A STRING ARRAY (INSERT,
DELETE, PEEK, ISEMPTY, ISFULL)</b>

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define MAX_SIZE 5
#define MAX_STRING_LENGTH 50

char priorityQueue[MAX_SIZE][MAX_STRING_LENGTH];
int size = 0;

int isFull() {
    return size == MAX_SIZE;
}

int isEmpty() {
    return size == 0;
}

int compareStrings(char *str1, char *str2) {
    while (*str1 != '\0' && *str2 != '\0') {
        if (*str1 &lt; *str2) {
            return -1;
        } else if (*str1 &gt; *str2) {
            return 1;
        }
        str1++;
        str2++;
    }
    if (*str1 == '\0' && *str2 == '\0') {
        return 0;
    }
    return (*str1 == '\0') ? -1 : 1;
}

void copyString(char *destination, char *source) {
    while ((*destination++ = *source++) != '\0');
}

void insert(char *element) {
    if (isFull()) {
        printf("Priority Queue is full. Cannot insert \"%s\".\n", element);
        return;
    }

    int i;
    for (i = size - 1; (i &gt;= 0 && compareStrings(priorityQueue[i], element) &lt; 0); i--) {
        copyString(priorityQueue[i + 1], priorityQueue[i]);
    }
    copyString(priorityQueue[i + 1], element);
    size++;
    printf("Inserted \"%s\" into the priority queue.\n", element);
}

void delete() {
    if (isEmpty()) {
        printf("Priority Queue is empty. Cannot delete.\n");
        return;
    }
    printf("Deleted \"%s\" from the priority queue.\n", priorityQueue[0]);
    for (int i = 0; i &lt; size - 1; i++) {
        copyString(priorityQueue[i], priorityQueue[i + 1]);
    }
    size--;
}

void peek() {
    if (isEmpty()) {
        printf("Priority Queue is empty. No element to peek.\n");
    } else {
        printf("Highest priority element: \"%s\"\n", priorityQueue[0]);
    }
}

int main() {
    int choice;
    char value[MAX_STRING_LENGTH];
    printf("\nPriority Queue Operations:\n");
    printf("1. Insert\n");
    printf("2. Delete\n");
    printf("3. Peek\n");
    printf("4. Is Empty\n");
    printf("5. Is Full\n");
    printf("6. Exit\n");

    while (1) {
        printf("Enter your choice: ");
        scanf("%d", &amp;choice);

        switch (choice) {
            case 1:
                printf("Enter a string to insert: ");
                scanf("%s", value);
                insert(value);
                break;
            case 2:
                delete();
                break;
            case 3:
                peek();
                break;
            case 4:
                if (isEmpty()) {
                    printf("Priority Queue is empty.\n");
                } else {
                    printf("Priority Queue is not empty.\n");
                }
                break;
            case 5:
                if (isFull()) {
                    printf("Priority Queue is full.\n");
                } else {
                    printf("Priority Queue is not full.\n");
                }
                break;
            case 6:
                exit(0);
            default:
                printf("Invalid choice. Please enter a valid option.\n");
        }
    }

    return 0;
}


</pre>
<pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>

Priority Queue Operations:
1. Insert
2. Delete
3. Peek
4. Is Empty
5. Is Full
6. Exit
Enter your choice: 1
Enter a string to insert: apple
Inserted "apple" into the priority queue.
Enter your choice: 1
Enter a string to insert: banana
Inserted "banana" into the priority queue.
Enter your choice: 1
Enter a string to insert: cherry
Inserted "cherry" into the priority queue.
Enter your choice: 3
Highest priority element: "cherry"
Enter your choice: 2
Deleted "cherry" from the priority queue.
Enter your choice: 4
Priority Queue is not empty.
Enter your choice: 5
Priority Queue is not full.
Enter your choice: 1
Enter a string to insert: date
Inserted "date" into the priority queue.
Enter your choice: 6


</pre>

<pre>
<br>
<b id="qu9">9.IMPLEMENT THE OPERATIONS OF DOUBLE ENDED QUEUE IN AN INTEGER ARRAY
(INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</b> 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int front = -1;
int rear = -1;

void insert(int *queue, int size) {
    int item;
    if (rear == size - 1) {
        printf("The queue is full.\n");
        return;
    }

    printf("Enter the item: ");
    scanf("%d", &item);

    if (front == -1 && rear == -1) {
        front = rear = 0;
    } else {
        rear++;
    }
    queue[rear] = item;
    printf("Item inserted %d at rear = %d, front = %d\n", queue[rear], rear, front);
}

void delete(int *queue) {
    if (front == -1 && rear == -1) {
        printf("The queue is empty.\n");
        return;
    }

    printf("Item deleted %d at front = %d, rear = %d\n", queue[front], front, rear);

    if (front == rear) {
        front = rear = -1;
    } else {
        front++;
    }
    printf("Current front = %d, rear = %d\n", front, rear);
}

void peek(int *queue) {
    if (front == -1 && rear == -1) {
        printf("The queue is empty.\n");
    } else {
        printf("Front element: %d\n", queue[front]);
    }
}

void isempty() {
    if (front == -1 && rear == -1) {
        printf("The queue is empty.\n");
    } else {
        printf("The queue is not empty.\n");
    }
}

void isfull(int size) {
    if (rear == size - 1) {
        printf("The queue is full.\n");
    } else {
        printf("The queue is not full.\n");
    }
}

int main() {
    int choice;
    int queue[5];

    printf("\nEnter 1 for insert()");
    printf("\nEnter 2 for delete()");
    printf("\nEnter 3 for peek()");
    printf("\nEnter 4 for isempty()");
    printf("\nEnter 5 for isfull()");
    printf("\nEnter 6 to exit\n");

    while (1) {
        printf("\nEnter your choice: ");
        scanf("%d", &choice);
        switch (choice) {
            case 1:
                insert(queue, 5);
                break;
            case 2:
                delete(queue);
                break;
            case 3:
                peek(queue);
                break;
            case 4:
                isempty();
                break;
            case 5:
                isfull(5);
                break;
            case 6:
                exit(0);
            default:
                printf("INVALID INPUT\n");
                break;
        }
    }

    return 0;
}


</pre>
<pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>

Enter 1 for insert()
Enter 2 for delete()
Enter 3 for peek()
Enter 4 for isempty()
Enter 5 for isfull()
Enter 6 to exit

Enter your choice: 1
Enter the item: 10
Item inserted 10 at rear = 0, front = 0

Enter your choice: 1
Enter the item: 20
Item inserted 20 at rear = 1, front = 0

Enter your choice: 3
Front element: 10

Enter your choice: 4
The queue is not empty.

Enter your choice: 5
The queue is not full.

Enter your choice: 2
Item deleted 10 at front = 0, rear = 1
Current front = 1, rear = 1

Enter your choice: 2
Item deleted 20 at front = 1, rear = 1
Current front = -1, rear = -1

Enter your choice: 4
The queue is empty.


</pre>

<pre>
<br>
<b id="qu10">10.IMPLEMENT THE OPERATIONS OF DOUBLE ENDED QUEUE IN A STRING ARRAY
(INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</b>

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define MAX_SIZE 5
#define STRING_LENGTH 100

int front = -1;
int rear = -1;

void insert(char queue[MAX_SIZE][STRING_LENGTH]) {
    char item[STRING_LENGTH];
    if (rear == MAX_SIZE - 1) {
        printf("The queue is full.\n");
        return;
    }

    printf("Enter the item: ");
    scanf("%s", item);

    if (front == -1 && rear == -1) {
        front = rear = 0;
    } else {
        rear++;
    }
    strcpy(queue[rear], item);
    printf("Item inserted '%s' at rear = %d, front = %d\n", queue[rear], rear, front);
}

void delete(char queue[MAX_SIZE][STRING_LENGTH]) {
    if (front == -1 && rear == -1) {
        printf("The queue is empty.\n");
        return;
    }

    printf("Item deleted '%s' at front = %d, rear = %d\n", queue[front], front, rear);

    if (front == rear) {
        front = rear = -1;
    } else {
        front++;
    }
    printf("Current front = %d, rear = %d\n", front, rear);
}

void peek(char queue[MAX_SIZE][STRING_LENGTH]) {
    if (front == -1 && rear == -1) {
        printf("The queue is empty.\n");
    } else {
        printf("Front element: '%s'\n", queue[front]);
    }
}

void isempty() {
    if (front == -1 && rear == -1) {
        printf("The queue is empty.\n");
    } else {
        printf("The queue is not empty.\n");
    }
}

void isfull() {
    if (rear == MAX_SIZE - 1) {
        printf("The queue is full.\n");
    } else {
        printf("The queue is not full.\n");
    }
}

int main() {
    int choice;
    char queue[MAX_SIZE][STRING_LENGTH];

    printf("\nEnter 1 for insert()");
    printf("\nEnter 2 for delete()");
    printf("\nEnter 3 for peek()");
    printf("\nEnter 4 for isempty()");
    printf("\nEnter 5 for isfull()");
    printf("\nEnter 6 to exit\n");

    while (1) {
        printf("\nEnter your choice: ");
        scanf("%d", &choice);
        switch (choice) {
            case 1:
                insert(queue);
                break;
            case 2:
                delete(queue);
                break;
            case 3:
                peek(queue);
                break;
            case 4:
                isempty();
                break;
            case 5:
                isfull();
                break;
            case 6:
                exit(0);
            default:
                printf("INVALID INPUT\n");
                break;
        }
    }

    return 0;
}


</pre>
<pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>  

Enter 1 for insert()
Enter 2 for delete()
Enter 3 for peek()
Enter 4 for isempty()
Enter 5 for isfull()
Enter 6 to exit

Enter your choice: 1
Enter the item: Hello
Item inserted 'Hello' at rear = 0, front = 0

Enter your choice: 1
Enter the item: World
Item inserted 'World' at rear = 1, front = 0

Enter your choice: 3
Front element: 'Hello'

Enter your choice: 4
The queue is not empty.

Enter your choice: 5
The queue is not full.

Enter your choice: 2
Item deleted 'Hello' at front = 0, rear = 1
Current front = 1, rear = 1

Enter your choice: 3
Front element: 'World'

Enter your choice: 2
Item deleted 'World' at front = 1, rear = 1
Current front = -1, rear = -1

Enter your choice: 4
The queue is empty.

Enter your choice: 5
The queue is not full.

Enter your choice: 6


</pre>

<pre>
<br>
<b id="qu11">11.IMPLEMENT THE OPERATIONS OF PRIORITY QUEUE DYNAMICALLY OF INTEGERS
(INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</b>

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct Node {
    int data;
    struct Node* next;
} Node;

Node* front = NULL;

int isEmpty() {
    return front == NULL;
}

void insert(int element) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = element;
    newNode->next = NULL;

    if (isEmpty() || front->data &lt; element) {
        newNode->next = front;
        front = newNode;
    } else {
        Node* current = front;
        while (current->next != NULL && current->next->data &gt;= element) {
            current = current->next;
        }
        newNode->next = current->next;
        current->next = newNode;
    }
    printf("Inserted %d into the priority queue.\n", element);
}

void delete() {
    if (isEmpty()) {
        printf("Priority Queue is empty. Cannot delete.\n");
        return;
    }
    Node* temp = front;
    front = front->next;
    printf("Deleted %d from the priority queue.\n", temp->data);
    free(temp);
}

void peek() {
    if (isEmpty()) {
        printf("Priority Queue is empty. No element to peek.\n");
    } else {
        printf("Highest priority element: %d\n", front->data);
    }
}

int isFull() {
    return 0;
}

int main() {
    int choice, value;
    printf("\nPriority Queue Operations:\n");
    printf("1. Insert\n");
    printf("2. Delete\n");
    printf("3. Peek\n");
    printf("4. Is Empty\n");
    printf("5. Is Full\n");
    printf("6. Exit\n");

    while (1) {
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter an integer to insert: ");
                scanf("%d", &value);
                insert(value);
                break;
            case 2:
                delete();
                break;
            case 3:
                peek();
                break;
            case 4:
                if (isEmpty()) {
                    printf("Priority Queue is empty.\n");
                } else {
                    printf("Priority Queue is not empty.\n");
                }
                break;
            case 5:
                if (isFull()) {
                    printf("Priority Queue is full.\n");
                } else {
                    printf("Priority Queue is not full.\n");
                }
                break;
            case 6:
                exit(0);
            default:
                printf("Invalid choice. Please enter a valid option.\n");
        }
    }

    return 0;
}


</pre>
<pre class="out">
<h3 style="text-align: center;">OUTPUT</h3> 

Priority Queue Operations:
1. Insert
2. Delete
3. Peek
4. Is Empty
5. Is Full
6. Exit
Enter your choice: 1
Enter an integer to insert: 10
Inserted 10 into the priority queue.
Enter your choice: 1
Enter an integer to insert: 20
Inserted 20 into the priority queue.
Enter your choice: 1
Enter an integer to insert: 15
Inserted 15 into the priority queue.
Enter your choice: 3
Highest priority element: 20
Enter your choice: 4
Priority Queue is not empty.
Enter your choice: 2
Deleted 20 from the priority queue.
Enter your choice: 3
Highest priority element: 15
Enter your choice: 2
Deleted 15 from the priority queue.
Enter your choice: 2
Deleted 10 from the priority queue.
Enter your choice: 2
Priority Queue is empty. Cannot delete.
Enter your choice: 4
Priority Queue is empty.
Enter your choice: 6


</pre>

<pre>
<br>
<b id="qu12">12.IMPLEMENT THE OPERATIONS OF PRIORITY QUEUE DYNAMICALLY OF STRING
(INSERT, DELETE, PEEK, ISEMPTY, ISFULL)</b>

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct Node {
    char* data;
    struct Node* next;
};

struct Node* front = NULL;

int isEmpty() {
    return front == NULL;
}

void insert(char* element) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = (char*)malloc(100);
    int i;
    for (i = 0; element[i] != '\0'; i++) {
        newNode->data[i] = element[i];
    }
    newNode->data[i] = '\0';
    newNode->next = NULL;

    if (isEmpty() || strcmp(front->data, newNode->data) &lt; 0) {
        newNode->next = front;
        front = newNode;
    } else {
        struct Node* current = front;
        while (current->next != NULL && strcmp(current->next->data, newNode->data) &gt;= 0) {
            current = current->next;
        }
        newNode->next = current->next;
        current->next = newNode;
    }
    printf("Inserted '%s' into the priority queue.\n", newNode->data);
}

void delete() {
    if (isEmpty()) {
        printf("Priority Queue is empty. Cannot delete.\n");
        return;
    }
    struct Node* temp = front;
    front = front->next;
    printf("Deleted '%s' from the priority queue.\n", temp->data);
    free(temp->data);
    free(temp);
}

void peek() {
    if (isEmpty()) {
        printf("Priority Queue is empty. No element to peek.\n");
    } else {
        printf("Highest priority element: '%s'\n", front->data);
    }
}

int isFull() {
    return 0;
}

int main() {
    int choice;
    char value[100];

    printf("\nPriority Queue Operations:\n");
    printf("1. Insert\n");
    printf("2. Delete\n");
    printf("3. Peek\n");
    printf("4. Is Empty\n");
    printf("5. Is Full\n");
    printf("6. Exit\n");

    while (1) {
        printf("Enter your choice: ");
        scanf("%d", &choice);
        getchar();

        switch (choice) {
            case 1:
                printf("Enter a string to insert: ");
                fgets(value, sizeof(value), stdin);
                value[strcspn(value, "\n")] = 0;
                insert(value);
                break;
            case 2:
                delete();
                break;
            case 3:
                peek();
                break;
            case 4:
                if (isEmpty()) {
                    printf("Priority Queue is empty.\n");
                } else {
                    printf("Priority Queue is not empty.\n");
                }
                break;
            case 5:
                if (isFull()) {
                    printf("Priority Queue is full.\n");
                } else {
                    printf("Priority Queue is not full.\n");
                }
                break;
            case 6:
                exit(0);
            default:
                printf("Invalid choice. Please enter a valid option.\n");
        }
    }

    return 0;
}


</pre>
<pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>

Priority Queue Operations:
1. Insert
2. Delete
3. Peek
4. Is Empty
5. Is Full
6. Exit
Enter your choice: 1
Enter a string to insert: apple
Inserted 'apple' into the priority queue.
Enter your choice: 1
Enter a string to insert: banana
Inserted 'banana' into the priority queue.
Enter your choice: 1
Enter a string to insert: cherry
Inserted 'cherry' into the priority queue.
Enter your choice: 3
Highest priority element: 'cherry'
Enter your choice: 2
Deleted 'cherry' from the priority queue.
Enter your choice: 3
Highest priority element: 'banana'
Enter your choice: 4
Priority Queue is not empty.
Enter your choice: 5
Priority Queue is not full.
Enter your choice: 2
Deleted 'banana' from the priority queue.
Enter your choice: 2
Deleted 'apple' from the priority queue.
Enter your choice: 4
Priority Queue is empty.
Enter your choice: 1
Enter a string to insert: date
Inserted 'date' into the priority queue.
Enter your choice: 6


</pre>


<pre>
<br>
<b id="qu13">13. Find the first circular tour that visits all petrol pumps.</b>

#include &lt;stdio.h&gt;

#define MAX 1000

int findCircularTour(int petrol[], int distance[], int n) {
    int start = 0, end = 1;
    int curr_petrol = petrol[start] - distance[start];

    while (end != start || curr_petrol &lt; 0) {
        // If current petrol is negative, reset the start position
        while (curr_petrol &lt; 0 && start != end) {
            curr_petrol -= petrol[start] - distance[start];
            start = (start + 1) % n;

            // If we reset the start, we also need to set end to start
            if (start == 0) return -1; // Not possible to complete the tour
        }

        curr_petrol += petrol[end] - distance[end];
        end = (end + 1) % n;
    }

    return start; // Return the starting index of the tour
}

int main() {
    int petrol[MAX], distance[MAX];
    int n;

    printf("Enter the number of petrol pumps: ");
    scanf("%d", &n);

    printf("Enter the petrol amounts at each pump:\n");
    for (int i = 0; i &lt; n; i++) {
        scanf("%d", &petrol[i]);
    }

    printf("Enter the distances to the next pump:\n");
    for (int i = 0; i &lt; n; i++) {
        scanf("%d", &distance[i]);
    }

    int start = findCircularTour(petrol, distance, n);
    if (start == -1) {
        printf("No circular tour is possible.\n");
    } else {
        printf("The circular tour can start at pump index: %d\n", start);
    }

    return 0;
}

</pre>
<pre class="out">
<h3 style="text-align: center;">OUTPUT</h3> 

Enter the number of petrol pumps: 5
Enter the petrol amounts at each pump:
4
6
7
4
5
Enter the distances to the next pump:
6
5
3
5
4

The circular tour can start at pump index: 1    

</pre>

<pre>
<br>
<b id="qu14">14. Length of the longest valid substring.</b>

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int longestValidParentheses(char *s) {
    int max_length = 0;
    int *stack = (int *)malloc(sizeof(int) * (strlen(s) + 1));
    int top = -1;
    
    stack[++top] = -1;

    for (int i = 0; s[i] != '\0'; i++) {
        if (s[i] == '(') {
            stack[++top] = i;
        } else {
            top--;
            if (top >= 0) {
                max_length = max_length &gt; (i - stack[top]) ? max_length : (i - stack[top]);
            } else {
                stack[++top] = i;
            }
        }
    }

    free(stack);
    return max_length;
}

int main() {
    char s[100];
    printf("Enter a string of parentheses: ");
    scanf("%s", s);
    
    int result = longestValidParentheses(s);
    printf("Length of the longest valid substring: %d\n", result);
    
    return 0;
}

</pre>
<pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>

Enter a string of parentheses: (()())(()
Length of the longest valid substring: 6

</pre>

<pre>
<br>
<b id="qu15">15. Find the Next Greater Element</b>

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void nextGreaterElement(int arr[], int n) {
    int *next = (int *)malloc(n * sizeof(int));
    int *stack = (int *)malloc(n * sizeof(int));
    int top = -1;

    for (int i = 0; i &lt; n; i++) {
        next[i] = -1;
    }

    for (int i = 0; i &lt; n; i++) {
        while (top &gt;= 0 && arr[stack[top]] &lt; arr[i]) {
            next[stack[top]] = arr[i];
            top--;
        }
        stack[++top] = i;
    }

    printf("Next Greater Element:\n");
    for (int i = 0; i &lt; n; i++) {
        if (next[i] != -1) {
            printf("Element %d -&gt; Next Greater Element: %d\n", arr[i], next[i]);
        } else {
            printf("Element %d -&gt; Next Greater Element: None\n", arr[i]);
        }
    }

    free(next);
    free(stack);
}

int main() {
    int arr[] = {4, 5, 2, 10, 8};
    int n = sizeof(arr) / sizeof(arr[0]);

    nextGreaterElement(arr, n);

    return 0;
}

</pre>
<pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>

Next Greater Element:
Element 4 -&gt; Next Greater Element: 5
Element 5 -&gt; Next Greater Element: 10
Element 2 -&gt; Next Greater Element: 10
Element 10 -&gt; Next Greater Element: None
Element 8 -&gt; Next Greater Element: None

</pre>

<pre>
<br>
<b id="qu16">16. Find Next Smaller Element.</b> 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void nextSmallerElement(int arr[], int n) {
    int *next = (int *)malloc(n * sizeof(int));
    int *stack = (int *)malloc(n * sizeof(int));
    int top = -1;

    for (int i = 0; i &lt; n; i++) {
        next[i] = -1;
    }

    for (int i = 0; i &lt; n; i++) {
        while (top &gt;= 0 && arr[stack[top]] &gt; arr[i]) {
            next[stack[top]] = arr[i];
            top--;
        }
        stack[++top] = i;
    }

    printf("Next Smaller Element:\n");
    for (int i = 0; i &lt; n; i++) {
        if (next[i] != -1) {
            printf("Element %d -&gt; Next Smaller Element: %d\n", arr[i], next[i]);
        } else {
            printf("Element %d -&gt; Next Smaller Element: None\n", arr[i]);
        }
    }

    free(next);
    free(stack);
}

int main() {
    int arr[] = {4, 5, 2, 10, 8};
    int n = sizeof(arr) / sizeof(arr[0]);

    nextSmallerElement(arr, n);

    return 0;
}

</pre>
<pre class="out">
<h3 style="text-align: center;">OUTPUT</h3> 

Next Smaller Element:
Element 4 -> Next Smaller Element: 2
Element 5 -> Next Smaller Element: 2
Element 2 -> Next Smaller Element: None
Element 10 -> Next Smaller Element: 8
Element 8 -> Next Smaller Element: 2

</pre>

<pre>
<br>
<b id="qu17">17. Queue based approach for first non-repeating character in a stream.</b>

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define MAX_CHARS 256

typedef struct Node {
    char data;
    struct Node *next;
} Node;

typedef struct Queue {
    Node *front, *rear;
} Queue;

Queue* createQueue() {
    Queue *q = (Queue *)malloc(sizeof(Queue));
    q-&gt;front = q-&gt;rear = NULL;
    return q;
}

void enqueue(Queue *q, char c) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode-&gt;data = c;
    newNode-&gt;next = NULL;
    if (q-&gt;rear == NULL) {
        q-&gt;front = q-&gt;rear = newNode;
        return;
    }
    q-&gt;rear-&gt;next = newNode;
    q-&gt;rear = newNode;
}

char dequeue(Queue *q) {
    if (q-&gt;front == NULL) {
        return '\0';
    }
    Node *temp = q-&gt;front;
    char data = temp-&gt;data;
    q-&gt;front = q-&gt;front-&gt;next;
    if (q-&gt;front == NULL) {
        q-&gt;rear = NULL;
    }
    free(temp);
    return data;
}

char firstNonRepeating(Queue *q, int count[]) {
    while (q-&gt;front != NULL && count[q-&gt;front-&gt;data] &gt; 1) {
        dequeue(q);
    }
    if (q-&gt;front != NULL) {
        return q-&gt;front-&gt;data;
    }
    return '\0';
}

int main() {
    char stream[] = "geeksforgeeks";
    int count[MAX_CHARS] = {0};
    Queue *q = createQueue();

    printf("First non-repeating characters in the stream:\n");
    for (int i = 0; stream[i] != '\0'; i++) {
        char current = stream[i];
        count[current]++;
        enqueue(q, current);

        char nonRepeating = firstNonRepeating(q, count);
        if (nonRepeating != '\0') {
            printf("%c ", nonRepeating);
        } else {
            printf("# ");
        }
    }

    printf("\n");
    return 0;
}

</pre>
<pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>

First non-repeating characters in the stream:
g g e e k k s f 

</pre>

<pre>
<br>
<b id="qu18">18. Reverse First K elements of Queue</b> 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct {
    int *data;
    int front;
    int rear;
    int capacity;
} Queue;

Queue* createQueue(int capacity) {
    Queue* queue = (Queue*)malloc(sizeof(Queue));
    queue-&gt;capacity = capacity;
    queue-&gt;front = 0;
    queue-&gt;rear = -1;
    queue-&gt;data = (int*)malloc(capacity * sizeof(int));
    return queue;
}

int isFull(Queue* queue) {
    return queue-&gt;rear == queue-&gt;capacity - 1;
}

int isEmpty(Queue* queue) {
    return queue-&gt;front &gt; queue-&gt;rear;
}

void enqueue(Queue* queue, int value) {
    if (!isFull(queue)) {
        queue-&gt;data[++queue-&gt;rear] = value;
    }
}

int dequeue(Queue* queue) {
    if (!isEmpty(queue)) {
        return queue-&gt;data[queue-&gt;front++];
    }
    return -1; // Queue is empty
}

void reverseFirstKElements(Queue* queue, int k) {
    if (k &gt; queue-&gt;rear + 1) return;

    int *stack = (int *)malloc(k * sizeof(int));
    int top = -1;

    for (int i = 0; i &lt; k; i++) {
        stack[++top] = dequeue(queue);
    }

    while (top != -1) {
        enqueue(queue, stack[top--]);
    }

    int remaining = queue-&gt;rear - (k - 1);
    for (int i = 0; i &lt; remaining; i++) {
        enqueue(queue, dequeue(queue));
    }

    free(stack);
}

void printQueue(Queue* queue) {
    for (int i = queue-&gt;front; i &lt;= queue-&gt;rear; i++) {
        printf("%d ", queue-&gt;data[i]);
    }
    printf("\n");
}

int main() {
    Queue* queue = createQueue(100);
    
    enqueue(queue, 1);
    enqueue(queue, 2);
    enqueue(queue, 3);
    enqueue(queue, 4);
    enqueue(queue, 5);

    printf("Original Queue: ");
    printQueue(queue);

    int k = 3;
    reverseFirstKElements(queue, k);

    printf("Queue after reversing first %d elements: ", k);
    printQueue(queue);

    free(queue-&gt;data);
    free(queue);
    return 0;
}

</pre>
<pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>

Original Queue: 1 2 3 4 5 
Queue after reversing first 3 elements: 3 2 1 4 5 

</pre>


<pre>
<br>
<b id="qu19">19. Queue Reversal</b>  

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct {
    int *data;
    int front;
    int rear;
    int capacity;
} Queue;

Queue* createQueue(int capacity) {
    Queue* queue = (Queue*)malloc(sizeof(Queue));
    queue-&gt;capacity = capacity;
    queue-&gt;front = 0;
    queue-&gt;rear = -1;
    queue-&gt;data = (int*)malloc(capacity * sizeof(int));
    return queue;
}

int isFull(Queue* queue) {
    return queue-&gt;rear == queue-&gt;capacity - 1;
}

int isEmpty(Queue* queue) {
    return queue-&gt;front &gt; queue-&gt;rear;
}

void enqueue(Queue* queue, int value) {
    if (!isFull(queue)) {
        queue-&gt;data[++queue-&gt;rear] = value;
    }
}

int dequeue(Queue* queue) {
    if (!isEmpty(queue)) {
        return queue-&gt;data[queue-&gt;front++];
    }
    return -1; // Queue is empty
}

void reverseQueueUsingStack(Queue* queue) {
    int size = queue-&gt;rear - queue-&gt;front + 1;
    int *stack = (int *)malloc(size * sizeof(int));
    int top = -1;

    while (!isEmpty(queue)) {
        stack[++top] = dequeue(queue);
    }

    while (top != -1) {
        enqueue(queue, stack[top--]);
    }

    free(stack);
}

void printQueue(Queue* queue) {
    for (int i = queue-&gt;front; i &lt;= queue-&gt;rear; i++) {
        printf("%d ", queue-&gt;data[i]);
    }
    printf("\n");
}

int main() {
    Queue* queue = createQueue(100);
    
    enqueue(queue, 1);
    enqueue(queue, 2);
    enqueue(queue, 3);
    enqueue(queue, 4);
    enqueue(queue, 5);

    printf("Original Queue: ");
    printQueue(queue);

    reverseQueueUsingStack(queue);

    printf("Reversed Queue: ");
    printQueue(queue);

    free(queue-&gt;data);
    free(queue);
    return 0;
}

</pre>
<pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>

Original Queue: 1 2 3 4 5 
Reversed Queue: 5 4 3 2 1 

</pre>

<pre>
<br>
<b id="qu20">20. Rotten Oranges</b>

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define MAX 1000

typedef struct {
    int x, y;
} Point;

int orangesRotting(int grid[MAX][MAX], int rows, int cols) {
    int freshCount = 0;
    int minutes = 0;
    Point queue[MAX * MAX];
    int front = 0, rear = 0;

    int directions[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

    for (int i = 0; i &lt; rows; i++) {
        for (int j = 0; j &lt; cols; j++) {
            if (grid[i][j] == 1) {
                freshCount++;
            } else if (grid[i][j] == 2) {
                queue[rear++] = (Point){i, j}; // Enqueue rotten orange position
            }
        }
    }

    while (front &lt; rear) {
        int size = rear - front;
        for (int i = 0; i &lt; size; i++) {
            Point current = queue[front++];
            for (int j = 0; j &lt; 4; j++) {
                int newX = current.x + directions[j][0];
                int newY = current.y + directions[j][1];
                if (newX &gt;= 0 && newX &lt; rows && newY &gt;= 0 && newY &lt; cols && grid[newX][newY] == 1) {
                    grid[newX][newY] = 2;
                    freshCount--;
                    queue[rear++] = (Point){newX, newY};
                }
            }
        }
        if (rear &gt; front) {
            minutes++;
        }
    }

    return freshCount == 0 ? minutes : -1;
}

int main() {
    int grid[MAX][MAX] = {
        {2, 1, 1, 0},
        {1, 1, 0, 2},
        {0, 1, 1, 2}
    };
    int rows = 3, cols = 4;

    int result = orangesRotting(grid, rows, cols);
    printf("Time taken for all oranges to rot: %d\n", result);

    return 0;
}

    </pre>
<pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>
    
Time taken for all oranges to rot: 2
    
</pre>

     </div>
                                                                
    <button class="back-to-top" id="backToTopBtn">Back to Top</button>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script>
        hljs.highlightAll();

        // Get the button
        const backToTopBtn = document.getElementById("backToTopBtn");

        // Show or hide the button based on scroll position
        window.onscroll = function () {
            if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
                backToTopBtn.style.display = "block";
            } else {
                backToTopBtn.style.display = "none";
            }
        };

        // Scroll to the top when the button is clicked
        backToTopBtn.onclick = function () {
            document.body.scrollTop = 0; // For Safari
            document.documentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
        };
    </script>
</body>

</html>