<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sorting Algorithm</title>
    <style>
        /* General reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            /* Same background color */
            color: #33334d;
            /* Dark text color */
        }

        .container {
            display: flex;
            min-height: 100vh;
        }

        /* Navigation Bar (on the left side) */
        .navbar {
            width: 250px;
            background-color: #33334d;
            /* Preferred dark color */
            padding: 20px;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            overflow-y: auto;
            position: fixed;
            /* Keep navbar fixed to the left */
            height: 100vh;
            /* Full height to fill the left side */
        }

        .navlist {
            list-style: none;
            padding: 0;
        }

        .navlist li {
            margin: 10px 0;
        }

        .navlist a {
            text-decoration: none;
            color: #ceb040;
            /* Gold text */
            font-weight: bold;
            font-size: 18px;
            padding: 10px;
            display: block;
            transition: background-color 0.3s ease;
        }

        .navlist a:hover {
            background-color: #6d5c6a;
            /* Soft purple hover effect */
            color: #f4f4f4;
        }

        /* Main content */
        .main-content {
            flex-grow: 1;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }

        .box-main {
            max-width: 800px;
            width: 100%;
            margin-left: 170px;
            background-color: #fff;
            /* White background for the box */
            padding: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            border: 2px solid #ceb040;
            /* Gold border */
        }

        .firsthalf2 ul {
            list-style: none;
        }

        .firsthalf2 li {
            margin: 10px 0;
        }

        .firsthalf2 a {
            text-decoration: none;
            font-size: 16px;
            color: #6d5c6a;
            font-family: 'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif;
            /* Soft purple color */
        }

        .firsthalf2 a:hover {
            color: #ceb040;
            /* Gold on hover */
        }

        .vasu {
            color: rgb(14, 13, 13);
            margin-left: 300px;
            max-width: 1000px;
            font-size: large;
            width: auto;
            background-color: #fff;
            /* White background for the box */
            padding: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            border: 4px solid #ceb040;
            word-wrap: break-word;
        }

        .vasu pre {
            word-wrap: break-word;
            white-space: pre-wrap;
            overflow-x: auto;
            padding: 10px;
            margin-bottom: 20px;
        }

        .vasu b {
            font-family: Arial, Helvetica, sans-serif;
            color: #ceb040;
        }

        .out {
            color: #fff;
            background-color: #111111;
        }

        .back-to-top {
            position: fixed;
            bottom: 20px;
            right: 10px;
            background-color: #ceb040;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 10px 15px;
            cursor: pointer;
            display: none;
            /* Hidden by default */
            z-index: 1000;
            /* On top of other elements */
        }

        .back-to-top:hover {
            background-color: #6d5c6a;
        }
    </style>
</head>

<body>
    <div class="container">
        <!-- Left Navigation Bar -->
        <nav class="navbar">
            <ul class="navlist">
                <li><a href="index.html">Home</a></li>
                <li><a href="2Darray.html">2D Array</a></li>
                <li><a href="graph.html">Graph</a></li>
                <li><a href="linkedlist.html">Linked List</a></li>
                <li><a href="queue.html">Queue</a></li>
                <li><a href="rec.html">Recursion</a></li>
                <li><a href="searching.html">Searching Algorithm</a></li>
                <li><a href="array.html">Single Dimension Array</a></li>
                <li><a href="sorting.html">Sorting Algorithm</a></li>
                <li><a href="stack.html">Stack</a></li>
                <li><a href="String.html">Strings</a></li>
                <li><a href="tree.html">Tree</a></li>
            </ul>
        </nav>

        <!-- Right Main Content -->
    <section class="main-content">
        <div class="box-main">
            <h1>SORTING ALGORITHM:- </h1> <!-- Added a heading for context -->
            <div class="firsthalf2">
                <ul>
                    <li><a href="#sortQ1">1. ENTER A INTEGER ARRAY FROM THE USER AND PERFORM SELECTION SORT
                            ALGORITHM THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT
                            TIME. ?</a></li>
                    <li><a href="#sortQ2">2. ENTER A INTEGER ARRAY FROM THE USER AND PERFORM SELECTION SORT
                            ALGORITHM THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT
                            TIME ?</a></li>
                    <li><a href="#sortQ3">3. ENTER A INTEGER ARRAY FROM THE USER AND PERFORM BUBBLE SORT ALGORITHM
                            THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME ?</a>
                    </li>
                    <li><a href="#sortQ4">4. ENTER A INTEGER ARRAY FROM THE USER AND PERFORM BUBBLE SORT ALGORITHM
                            THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME ?</a>
                    </li>
                    <li><a href="#sortQ5">5. ENTER A INTEGER ARRAY FROM THE USER AND PERFORM INSERTION SORT
                            ALGORITHM THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT
                            TIME ?</a></li>
                    <li><a href="#sortQ6">6. ENTER A INTEGER ARRAY FROM THE USER AND PERFORM INSERTION SORT
                            ALGORITHM THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT
                            TIME ?</a></li>
                    <li><a href="#sortQ7">7. ENTER A INTEGER ARRAY FROM THE USER AND PERFORM MERGE SORT ALGORITHM
                            THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME ?</a>
                    </li>
                    <li><a href="#sortQ8">8. ENTER A INTEGER ARRAY FROM THE USER AND PERFORM MERGE SORT ALGORITHM
                            THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME ?</a>
                    </li>
                    <li><a href="#sortQ9">9. ENTER A INTEGER ARRAY FROM THE USER AND PERFORM QUICK SORT ALGORITHM
                            THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME ?</a>
                    </li>
                    <li><a href="#sortQ10">10. ENTER A STRING ARRAY FROM THE USER AND PERFORM SELECTION SORT
                            ALGORITHM THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT
                            TIME ?</a></li>
                    <li><a href="#sortQ12">12. ENTER A STRING ARRAY FROM THE USER AND PERFORM SELECTION SORT
                            ALGORITHM THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT
                            TIME ?</a></li>
                    <li><a href="#sortQ13">13. ENTER A STRING ARRAY FROM THE USER AND PERFORM BUBBLE SORT ALGORITHM
                            THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME ?</a>
                    </li>
                    <li><a href="#sortQ14">14. ENTER A STRING ARRAY FROM THE USER AND PERFORM BUBBLE SORT ALGORITHM
                            THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME ?</a>
                    </li>
                    <li><a href="#sortQ15">15. ENTER A STRING ARRAY FROM THE USER AND PERFORM INSERTION SORT
                            ALGORITHM THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT
                            TIME ?</a>
                    </li>
                    <li><a href="#sortQ16">16. ENTER A STRING ARRAY FROM THE USER AND PERFORM INSERTION SORT
                            ALGORITHM THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT
                            TIME ?</a>
                    </li>
                    <li><a href="#sortQ17">17. ENTER A STRING ARRAY FROM THE USER AND PERFORM MERGE SORT ALGORITHM
                            THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME ?</a>
                    </li>
                    <li><a href="#sortQ18">18. ENTER A STRING ARRAY FROM THE USER AND PERFORM MERGE SORT ALGORITHM
                            THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME ?</a>
                    </li>
                    <li><a href="#sortQ19">19. ENTER A STRING ARRAY FROM THE USER AND PERFORM QUICK SORT ALGORITHM
                            THROUGH ITERATION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME ?</a>
                    </li>
                    <li><a href="#sortQ20">20. ENTER A STRING ARRAY FROM THE USER AND PERFORM QUICK SORT ALGORITHM
                            THROUGH RECURSION. ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME ?</a>
                    </li>

                </ul>
            </div>
        </div>
    </section>
</div>

    <div class="vasu">

        <pre class="pre">
<br>
<b id="sortQ1">1. ENTER A INTEGER ARRAY FROM THE USER AND PERFORM SELECTION SORT ALGORITHM THROUGH ITERATION. 
ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</b>

#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#define maxSize 100
void selectionSort(int arr[], int size) {
    int temp, min;
    for (int i = 0; i &lt; size; i++) {
        min = i;
        for (int j = i + 1; j &lt; size; j++) {
            if (arr[j] &lt; arr[min]) {
                min = j;
            }
        }
        temp = arr[i];
        arr[i] = arr[min];
        arr[min] = temp;
    }
}
int main() {
    int arr[maxSize];
    int size;
    clock_t start, end;
    printf("ENTER SIZE OF ARRAY : ");
    scanf("%d", &size);
    for (int i = 0; i &lt; size; i++) {
        printf("ENTER ARRAY ELEMENT : ");
        scanf("%d", &arr[i]);
    }
    for (int i = 0; i &lt; size; i++) {
        printf("%d ", arr[i]);
    }
    start = clock();
    selectionSort(arr, size);
    end = clock();
    printf("\n");
    for (int i = 0; i &lt; size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\nExecuted in %fs", (double)(end - start) / CLOCKS_PER_SEC);
    return 0;
}


</pre>
        <pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>

ENTER SIZE OF ARRAY : 5
ENTER ARRAY ELEMENT : 2
ENTER ARRAY ELEMENT : 25
ENTER ARRAY ELEMENT : 22
ENTER ARRAY ELEMENT : 6
ENTER ARRAY ELEMENT : 5
2 25 22 6 5
2 5 6 22 25
Executed in 0.000000s

</pre>

        <pre class="pre">
<br>
<b id="sortQ2">2. ENTER A INTEGER ARRAY FROM THE USER AND PERFORM SELECTION SORT ALGORITHM THROUGH RECURSION.ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</b>

#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#define maxSize 100
void selectionSort(int arr[], int size, int i, int j, int min) {
    if (i &lt; (size - 1)) {
        if (j == size) {
            int temp = arr[i];
            arr[i] = arr[min];
            arr[min] = temp;
            i++;
            min = i;
            j = min + 1;
        }
        if (arr[j] &lt; arr[min]) {
            selectionSort(arr, size, i, j + 1, j);
        } else {
            selectionSort(arr, size, i, j + 1, min);
        }
    }
}
int main() {
    int arr[maxSize];
    int size;
    clock_t start, end;
    printf("ENTER SIZE OF ARRAY : ");
    scanf("%d", &size);
    for (int i = 0; i &lt; size; i++) {
        printf("ENTER ARRAY ELEMENT : ");
        scanf("%d", &arr[i]);
    }
    for (int i = 0; i &lt; size; i++) {
        printf("%d ", arr[i]);
    }
    start = clock();
    selectionSort(arr, size, 0, 1, 0);
    end = clock();
    printf("\n");
    for (int i = 0; i &lt; size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\nExecuted in %fs\n", (double)(end - start) / CLOCKS_PER_SEC);
    return 0;
}



</pre>
        <pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>

ENTER SIZE OF ARRAY : 4
ENTER ARRAY ELEMENT : 2
ENTER ARRAY ELEMENT : 3
ENTER ARRAY ELEMENT : 6
ENTER ARRAY ELEMENT : 9
2 3 6 9
2 3 6 9
Executed in 0.000000s

</pre>

        <pre class="pre">
    <br>
<b id="sortQ3">3. ENTER A INTEGER ARRAY FROM THE USER AND PERFORM BUBBLE SORT ALGORITHM THROUGH ITERATION. 
ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</b>

#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#define maxSize 100
void bubbleSort(int arr[], int size) {
    int temp;
    for (int j = 0; j &lt; size; j++) {
        for (int i = 0; i &lt; (size - j - 1); i++) {
            if (arr[i] &gt; arr[i + 1]) {
                temp = arr[i];
                arr[i] = arr[i + 1];
                arr[i + 1] = temp;
            }
        }
    }
}
int main() {
    int arr[maxSize];
    int size;
    clock_t start, end;
    printf("ENTER SIZE OF ARRAY : ");
    scanf("%d", &size);
    for (int i = 0; i &lt; size; i++) {
        printf("ENTER ARRAY ELEMENT : ");
        scanf("%d", &arr[i]);
    }
    for (int i = 0; i &lt; size; i++) {
        printf("%d ", arr[i]);
    }
    start = clock();
    bubbleSort(arr, size);
    end = clock();
    printf("\n");
    for (int i = 0; i &lt; size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\nExecuted in %fs\n", (double)(end - start) / CLOCKS_PER_SEC);
    return 0;
}


</pre>
        <pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>

ENTER SIZE OF ARRAY : 5
ENTER ARRAY ELEMENT : 34
ENTER ARRAY ELEMENT : 12
ENTER ARRAY ELEMENT : 25
ENTER ARRAY ELEMENT : 9
ENTER ARRAY ELEMENT : 67
34 12 25 9 67 
9 12 25 34 67 
Executed in 0.000001s

</pre>

        <pre class="pre">
    <br>
<b id="sortQ4">4. ENTER A INTEGER ARRAY FROM THE USER AND PERFORM BUBBLE SORT ALGORITHM THROUGH RECURSION.
ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</b>

#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#define maxSize 100
void bubbleSort(int arr[], int size, int i, int j) {
    if (i &lt; size) {
        if (j &lt; (size - i - 1)) {
            if (arr[j] &gt; arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
            bubbleSort(arr, size, i, j + 1);
        }
        bubbleSort(arr, size, i + 1, 0);
    }
}
int main() {
    int arr[maxSize];
    int size;
    clock_t start, end;
    printf("ENTER SIZE OF ARRAY : ");
    scanf("%d", &size);
    for (int i = 0; i &lt; size; i++) {
        printf("ENTER ARRAY ELEMENT : ");
        scanf("%d", &arr[i]);
    }
    for (int i = 0; i &lt; size; i++) {
        printf("%d ", arr[i]);
    }
    start = clock();
    bubbleSort(arr, size, 0, 0);
    end = clock();
    printf("\n");
    for (int i = 0; i &lt; size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\nExecuted in %fs\n", (double)(end - start) / CLOCKS_PER_SEC);
    return 0;
}

</pre>
        <pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>

ENTER SIZE OF ARRAY : 5
ENTER ARRAY ELEMENT : 34
ENTER ARRAY ELEMENT : 12
ENTER ARRAY ELEMENT : 25
ENTER ARRAY ELEMENT : 9
ENTER ARRAY ELEMENT : 67
34 12 25 9 67 
9 12 25 34 67 
Executed in 0.000002s
</pre>

        <pre class="pre">
    <br>
<b id="sortQ5">5. ENTER A INTEGER ARRAY FROM THE USER AND PERFORM INSERTION SORT ALGORITHM THROUGH ITERATION.
ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</b>

#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#define maxSize 100
void insertionSort(int arr[], int size) {
    int temp;
    int i = 0;
    for (int j = i + 1; j &lt; size; j++) {
        temp = arr[j];
        int k = i;
        while ((arr[k] &gt; temp) && (k &gt;= 0)) {
            arr[k + 1] = arr[k];
            k--;
        }
        arr[k + 1] = temp;
        i++;
    }
}
int main() {
    int arr[maxSize];
    int size;
    clock_t start, end;
    printf("ENTER SIZE OF ARRAY : ");
    scanf("%d", &size);
    for (int i = 0; i &lt; size; i++) {
        printf("ENTER ARRAY ELEMENT : ");
        scanf("%d", &arr[i]);
    }
    for (int i = 0; i &lt; size; i++) {
        printf("%d ", arr[i]);
    }
    start = clock();
    insertionSort(arr, size);
    end = clock();
    printf("\n");
    for (int i = 0; i &lt; size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\nExecuted in %fs\n", (double)(end - start) / CLOCKS_PER_SEC);
    return 0;
}


</pre>
        <pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>

ENTER SIZE OF ARRAY : 5
ENTER ARRAY ELEMENT : 34
ENTER ARRAY ELEMENT : 12
ENTER ARRAY ELEMENT : 25
ENTER ARRAY ELEMENT : 9
ENTER ARRAY ELEMENT : 67
34 12 25 9 67 
9 12 25 34 67 
Executed in 0.000002s

</pre>

        <pre class="pre">
    <br>
<b id="sortQ6">6. ENTER A INTEGER ARRAY FROM THE USER AND PERFORM INSERTION SORT ALGORITHM THROUGH RECURSION.
ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</b>

#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#define maxSize 100
void insertionSort(int arr[], int n) {
    if (n &lt;= 1)
        return;

    insertionSort(arr, n - 1);

    int last = arr[n - 1];
    int j = n - 2;

    while (j &gt;= 0 && arr[j] &gt; last) {
        arr[j + 1] = arr[j];
        j--;
    }
    arr[j + 1] = last;
}

int main() {
    int arr[maxSize];
    int size;
    clock_t start, end;
    printf("ENTER SIZE OF ARRAY : ");
    scanf("%d", &size);
    for (int i = 0; i &lt; size; i++) {
        printf("ENTER ARRAY ELEMENT : ");
        scanf("%d", &arr[i]);
    }
    for (int i = 0; i &lt; size; i++) {
        printf("%d ", arr[i]);
    }
    start = clock();
    insertionSort(arr, size);
    end = clock();
    printf("\n");
    for (int i = 0; i &lt; size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\nExecuted in %fs\n", (double)(end - start) / CLOCKS_PER_SEC);
    return 0;
}


</pre>
        <pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>

ENTER SIZE OF ARRAY : 5
ENTER ARRAY ELEMENT : 34
ENTER ARRAY ELEMENT : 12
ENTER ARRAY ELEMENT : 25
ENTER ARRAY ELEMENT : 9
ENTER ARRAY ELEMENT : 67
34 12 25 9 67 
9 12 25 34 67 
Executed in 0.000002s
</pre>

        <pre class="pre">
    <br>
<b id="sortQ7">7. ENTER A INTEGER ARRAY FROM THE USER AND PERFORM MERGE SORT ALGORITHM THROUGH ITERATION.
ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</b>

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#define maxSize 100
void display(int arr[], int size) {
    for (int i = 0; i &lt; size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}
// Function to merge two subarrays
void merge(int arr[], int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    int L[n1], R[n2];

    // Copy data to temp arrays L[] and R[]
    for (int i = 0; i &lt; n1; i++)
        L[i] = arr[left + i];
    for (int j = 0; j &lt; n2; j++)
        R[j] = arr[mid + 1 + j];

    // Merge the temp arrays back into arr[left..right]
    int i = 0, j = 0, k = left;
    while (i &lt; n1 && j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    // Copy remaining elements of L[], if any
    while (i &lt; n1) {
        arr[k] = L[i];
        i++;
        k++;
    }

    // Copy remaining elements of R[], if any
    while (j &lt; n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}

// Iterative merge sort function
void mergeSort(int arr[], int n) {
    int curr_size;  // For current size of subarrays to be merged
    int left_start; // For picking starting index of left subarray

    // Merge subarrays in bottom up manner
    for (curr_size = 1; curr_size &lt;= n - 1; curr_size = 2 * curr_size) {
        // Pick starting point of different subarrays of current size
        for (left_start = 0; left_start &lt; n - 1; left_start += 2 * curr_size) {
            int mid = left_start + curr_size - 1;
            int right_end = (left_start + 2 * curr_size - 1 &lt; n - 1) ? (left_start + 2 * curr_size - 1) : (n - 1);

            // Merge subarrays arr[left_start...mid] & arr[mid+1...right_end]
            merge(arr, left_start, mid, right_end);
        }
    }
}
int main() {
    int arr[maxSize];
    int size;
    clock_t start, end;
    printf("ENTER SIZE OF ARRAY : ");
    scanf("%d", &size);
    for (int i = 0; i &lt; size; i++) {
        printf("ENTER ARRAY ELEMENT : ");
        scanf("%d", &arr[i]);
    }
    display(arr, size);
    start = clock();
    mergeSort(arr, size);
    end = clock();
    display(arr, size);
    printf("Executed in %fs\n", (double)(end - start) / CLOCKS_PER_SEC);
    return 0;
}



</pre>
        <pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>

ENTER SIZE OF ARRAY : 5
ENTER ARRAY ELEMENT : 34
ENTER ARRAY ELEMENT : 12
ENTER ARRAY ELEMENT : 25
ENTER ARRAY ELEMENT : 9
ENTER ARRAY ELEMENT : 67
34 12 25 9 67 
9 12 25 34 67 
Executed in 0.000003s


</pre>

        <pre class="pre">
    <br>
<b id="sortQ8">8. ENTER A INTEGER ARRAY FROM THE USER AND PERFORM MERGE SORT ALGORITHM THROUGH RECURSION.
    ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</b>

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#define maxSize 100
void display(int arr[], int size) {
    for (int i = 0; i &lt; size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}
// The array is divided into two halves until each sub-array contains a single element (which is inherently sorted).
void merge(int arr1[], int start, int mid, int end) {
    int i = start;
    int j = mid + 1;
    int k;
    int *temp = (int *)calloc(sizeof(int), end - start + 1);
    for (k = 0; k &lt;= (end - start); k++) {
        if ((i &lt;= mid) && (j &lt;= end)) {
            if (arr1[i] &lt;= arr1[j]) {
                temp[k] = arr1[i++];
            } else {
                temp[k] = arr1[j++];
            }
        } else {
            if (i &lt;= mid) {
                temp[k] = arr1[i++];
            } else {
                temp[k] = arr1[j++];
            }
        }
    }
    for (i = start; i &lt;= end; i++) {
        arr1[i] = temp[i - start];
    }
    free(temp);
}
void mergeSort(int arr[maxSize], int start, int end) {
    if (start &gt;= end) {
        return;
    } else {
        int mid = start + ((end - start) / 2);
        mergeSort(arr, start, mid);
        mergeSort(arr, mid + 1, end);
        merge(arr, start, mid, end);
    }
}
int main() {
    int arr[maxSize];
    int size;
    clock_t start, end;
    printf("ENTER SIZE OF ARRAY : ");
    scanf("%d", &size);
    for (int i = 0; i &lt; size; i++) {
        printf("ENTER ARRAY ELEMENT : ");
        scanf("%d", &arr[i]);
    }
    display(arr, size);
    start = clock();
    mergeSort(arr, 0, size - 1);
    end = clock();
    display(arr, size);
    printf("Executed in %fs\n", (double)(end - start) / CLOCKS_PER_SEC);
    return 0;
}
    


</pre>
        <pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>

ENTER SIZE OF ARRAY : 5
ENTER ARRAY ELEMENT : 34
ENTER ARRAY ELEMENT : 12
ENTER ARRAY ELEMENT : 25
ENTER ARRAY ELEMENT : 9
ENTER ARRAY ELEMENT : 67
34 12 25 9 67 
9 12 25 34 67 
Executed in 0.000003s


</pre>

        <pre class="pre">
    <br>
<b id="sortQ9">9. ENTER A INTEGER ARRAY FROM THE USER AND PERFORM QUICK SORT ALGORITHM THROUGH ITERATION.
        ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</b>

#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#define maxSize 100
// Function to swap two elements
void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

// Partition function for quicksort
int partition(int arr[], int low, int high) {
    int pivot = arr[high];
    int i = (low - 1);

    for (int j = low; j &lt;= high - 1; j++) {
        if (arr[j] &lt; pivot) {
            i++;
            swap(&arr[i], &arr[j]);
        }
    }
    swap(&arr[i + 1], &arr[high]);
    return (i + 1);
}

// Iterative QuickSort function
void quickSort(int arr[], int n) {
    int stack[n];
    int top = -1;

    // Initialize stack with initial values
    stack[++top] = 0;
    stack[++top] = n - 1;

    // Keep popping elements from the stack until it's empty
    while (top &gt;= 0) {
        int high = stack[top--];
        int low = stack[top--];

        int pivot = partition(arr, low, high);

        // If there are elements on the left side of the pivot, push left side to stack
        if (pivot - 1 &gt; low) {
            stack[++top] = low;
            stack[++top] = pivot - 1;
        }

        // If there are elements on the right side of the pivot, push right side to stack
        if (pivot + 1 &lt; high) {
            stack[++top] = pivot + 1;
            stack[++top] = high;
        }
    }
}

// Function to print an array
void display(int arr[], int size) {
    for (int i = 0; i &lt; size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    int arr[maxSize];
    int size;
    clock_t start, end;
    printf("ENTER SIZE OF ARRAY : ");
    scanf("%d", &size);
    for (int i = 0; i &lt; size; i++) {
        printf("ENTER ARRAY ELEMENT : ");
        scanf("%d", &arr[i]);
    }
    display(arr, size);
    start = clock();
    quickSort(arr, size);
    end = clock();
    display(arr, size);
    printf("Executed in %fs\n", (double)(end - start) / CLOCKS_PER_SEC);
    return 0;
}
        
</pre>
        <pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>

ENTER SIZE OF ARRAY : 5
ENTER ARRAY ELEMENT : 34
ENTER ARRAY ELEMENT : 12
ENTER ARRAY ELEMENT : 25
ENTER ARRAY ELEMENT : 9
ENTER ARRAY ELEMENT : 67
34 12 25 9 67 
9 12 25 34 67 
Executed in 0.000003s

</pre>

        <pre class="pre">
<br>
<b id="sortQ10">10. ENTER A INTEGER ARRAY FROM THE USER AND PERFORM QUICK SORT ALGORITHM THROUGH RECURSION.
     ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</b>

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#define maxSize 100
void display(int arr[], int size) {
    for (int i = 0; i &lt; size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int partition(int arr[], int start, int end) {
    int pivot = arr[start];
    int ind = start, temp;
    int i = start, j = end;
    for (int i = start; i &lt;= end; i++) {
        if (arr[i] &lt; pivot)
            ind++;
    }
    temp = arr[ind];
    arr[ind] = arr[start];
    arr[start] = temp;
    while ((i &lt; ind) &amp;&amp; (j &gt; ind)) {
        if (arr[i] &gt; pivot) {
            if (arr[j] &lt; pivot) {
                temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            } else
                j--;
        } else
            i++;
    }
    return ind;
}

// The quicksort algorithm operates by selecting a pivot element from the array and partitioning the other elements into two sub-arrays: those less than the pivot and those greater than the pivot. This process is repeated recursively for the sub-arrays until they are sorted.
void quickSort(int arr[maxSize], int start, int end) {
    if (start &gt;= end) {
        return;
    } else {
        int p = partition(arr, start, end);
        quickSort(arr, start, p - 1);
        quickSort(arr, p + 1, end);
    }
}

int main() {
    int arr[maxSize];
    int size;
    clock_t start, end;
    printf("ENTER SIZE OF ARRAY : ");
    scanf("%d", &size);
    for (int i = 0; i &lt; size; i++) {
        printf("ENTER ARRAY ELEMENT : ");
        scanf("%d", &arr[i]);
    }
    display(arr, size);
    start = clock();
    quickSort(arr, 0, size - 1);
    end = clock();
    display(arr, size);
    printf("Executed in %fs\n", (double)(end - start) / CLOCKS_PER_SEC);
    return 0;
}

</pre>
        <pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>

ENTER SIZE OF ARRAY : 5
ENTER ARRAY ELEMENT : 34
ENTER ARRAY ELEMENT : 12
ENTER ARRAY ELEMENT : 25
ENTER ARRAY ELEMENT : 9
ENTER ARRAY ELEMENT : 67
34 12 25 9 67 
9 12 25 34 67 
Executed in 0.000003s

</pre>

        <pre class="pre">
<br>
<b id="sortQ11">11. ENTER A STRING ARRAY FROM THE USER AND PERFORM SELECTION SORT ALGORITHM THROUGH ITERATION. 
    ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</b>

#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#define maxSize 100
// selection sorts looks for smallest element in the sorted array
void selectionSort(char arr[], int size) {
    char temp, min;
    for (int i = 0; i &lt; size; i++) {
        min = i;
        for (int j = i + 1; j &lt; size; j++) {
            if (arr[j] &lt; arr[min]) {
                min = j;
            }
        }
        temp = arr[i];
        arr[i] = arr[min];
        arr[min] = temp;
    }
}
int main() {
    char arr[maxSize];
    int size;
    clock_t start, end;
    printf("ENTER SIZE OF ARRAY : ");
    scanf("%d", &size);
    for (int i = 0; i &lt; size; i++) {
        printf("ENTER ARRAY ELEMENT : ");
        fflush(stdin);
        scanf(" %c", &arr[i]); // Added space before %c to consume any newline character
    }
    for (int i = 0; i &lt; size; i++) {
        printf("%c ", arr[i]);
    }
    start = clock();
    selectionSort(arr, size);
    end = clock();
    printf("\n");
    for (int i = 0; i &lt; size; i++) {
        printf("%c ", arr[i]);
    }
    printf("\nExecuted in %fs\n", (double)(end - start) / CLOCKS_PER_SEC);

    return 0;
}

</pre>
        <pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>

ENTER SIZE OF ARRAY : 5
ENTER ARRAY ELEMENT : b
ENTER ARRAY ELEMENT : a
ENTER ARRAY ELEMENT : d
ENTER ARRAY ELEMENT : c
ENTER ARRAY ELEMENT : e
b a d c e 
a b c d e 
Executed in 0.000002s

</pre>

        <pre class="pre">
<br>
<b id="sortQ12">12. ENTER A STRING ARRAY FROM THE USER AND PERFORM SELECTION SORT ALGORITHM THROUGH RECURSION. 
    ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</b>

#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#define maxSize 100
// selection sorts looks for smallest element in the sorted array
void selectionSort(char arr[], int size, int i, int j, int min) {
if (i &lt; (size - 1)) {
    if (j == size) {
        char temp = arr[i];
        arr[i] = arr[min];
        arr[min] = temp;
        i++;
        min = i;
        j = min + 1;
    }
    if (j &lt; size) {
        if (arr[j] &lt; arr[min]) {
            selectionSort(arr, size, i, j + 1, j);
        } else {
            selectionSort(arr, size, i, j + 1, min);
        }
    } else {
        selectionSort(arr, size, i, j, min);
    }
}
}
int main() {
char arr[maxSize];
int size;
clock_t start, end;
printf("ENTER SIZE OF ARRAY : ");
scanf("%d", &size);
for (int i = 0; i &lt; size; i++) {
    printf("ENTER ARRAY ELEMENT : ");
    fflush(stdin);
    scanf(" %c", &arr[i]); // Added space before %c to consume any newline character
}
for (int i = 0; i &lt; size; i++) {
    printf("%c ", arr[i]);
}
start = clock();
selectionSort(arr, size, 0, 1, 0);
end = clock();
printf("\n");
for (int i = 0; i &lt; size; i++) {
    printf("%c ", arr[i]);
}
printf("\nExecuted in %fs\n", (double)(end - start) / CLOCKS_PER_SEC);

return 0;
}

</pre>
        <pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>

ENTER SIZE OF ARRAY : 5
ENTER ARRAY ELEMENT : b
ENTER ARRAY ELEMENT : a
ENTER ARRAY ELEMENT : d
ENTER ARRAY ELEMENT : c
ENTER ARRAY ELEMENT : e
b a d c e 
a b c d e 
Executed in 0.000002s

</pre>

        <pre class="pre">
<br>
<b id="sortQ13">13. ENTER A STRING ARRAY FROM THE USER AND PERFORM BUBBLE SORT ALGORITHM THROUGH ITERATION.
     ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</b>

#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#define maxSize 100
// swaps the adjacent elements
void bubbleSort(char arr[], int size) {
    char temp;
    for (int j = 0; j &lt; size; j++) {
        for (int i = 0; i &lt; (size - j - 1); i++) {
            if (arr[i] &gt; arr[i + 1]) {
                temp = arr[i];
                arr[i] = arr[i + 1];
                arr[i + 1] = temp;
            }
        }
    }
}
int main() {
    char arr[maxSize];
    int size;
    clock_t start, end;
    printf("ENTER SIZE OF ARRAY : ");
    scanf("%d", &size);
    for (int i = 0; i &lt; size; i++) {
        printf("ENTER ARRAY ELEMENT : ");
        fflush(stdin);
        scanf(" %c", &arr[i]); // Added space before %c to consume any newline character
    }
    for (int i = 0; i &lt; size; i++) {
        printf("%c ", arr[i]);
    }
    start = clock();
    bubbleSort(arr, size);
    end = clock();
    printf("\n");
    for (int i = 0; i &lt; size; i++) {
        printf("%c ", arr[i]);
    }
    printf("\nExecuted in %fs\n", (double)(end - start) / CLOCKS_PER_SEC);
    return 0;
}


</pre>
        <pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>

ENTER SIZE OF ARRAY : 5
ENTER ARRAY ELEMENT : b
ENTER ARRAY ELEMENT : a
ENTER ARRAY ELEMENT : d
ENTER ARRAY ELEMENT : c
ENTER ARRAY ELEMENT : e
b a d c e 
a b c d e 
Executed in 0.000002s


</pre>

        <pre class="pre">
<br>
<b id="sortQ14">14. ENTER A STRING ARRAY FROM THE USER AND PERFORM BUBBLE SORT ALGORITHM THROUGH RECURSION.
     ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</b>

#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#define maxSize 100
// swaps the adjacent elements
void bubbleSort(char arr[], int size, int i, int j) {
    if (i &lt; size) {
        if (j &lt; (size - i - 1)) {
            if (arr[j] &gt; arr[j + 1]) {
                char temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
            bubbleSort(arr, size, i, j + 1);
        }
        bubbleSort(arr, size, i + 1, 0);
    }
}
int main() {
    char arr[maxSize];
    int size;
    clock_t start, end;
    printf("ENTER SIZE OF ARRAY : ");
    scanf("%d", &size);
    for (int i = 0; i &lt; size; i++) {
        printf("ENTER ARRAY ELEMENT : ");
        fflush(stdin);
        scanf(" %c", &arr[i]); // Added space before %c to consume any newline character
    }
    for (int i = 0; i &lt; size; i++) {
        printf("%c ", arr[i]);
    }
    start = clock();
    bubbleSort(arr, size, 0, 0);
    end = clock();
    printf("\n");
    for (int i = 0; i &lt; size; i++) {
        printf("%c ", arr[i]);
    }
    printf("\nExecuted in %fs\n", (double)(end - start) / CLOCKS_PER_SEC);
    return 0;
}

</pre>
        <pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>

ENTER SIZE OF ARRAY : 5
ENTER ARRAY ELEMENT : b
ENTER ARRAY ELEMENT : a
ENTER ARRAY ELEMENT : d
ENTER ARRAY ELEMENT : c
ENTER ARRAY ELEMENT : e
b a d c e 
a b c d e 
Executed in 0.000002s

</pre>

        <pre class="pre">
<br>
<b id="sortQ15">15. ENTER A STRING ARRAY FROM THE USER AND PERFORM INSERTION SORT ALGORITHM THROUGH ITERATION.
     ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</b>
    
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#define maxSize 100
// inserts element from unsorted array to sorted array at its correct place
void insertionSort(char arr[], int size) {
    char temp;
    int i = 0;
    for (int j = i + 1; j &lt; size; j++) {
        temp = arr[j];
        int k = i;
        while ((arr[k] &gt; temp) && (k &gt;= 0)) {
            arr[k + 1] = arr[k];
            k--;
        }
        arr[k + 1] = temp;
        i++;
    }
}
int main() {
    char arr[maxSize];
    int size;
    clock_t start, end;
    printf("ENTER SIZE OF ARRAY : ");
    scanf("%d", &size);
    for (int i = 0; i &lt; size; i++) {
        printf("ENTER ARRAY ELEMENT : ");
        fflush(stdin);
        scanf(" %c", &arr[i]); // Added space before %c to consume any newline character
    }
    for (int i = 0; i &lt; size; i++) {
        printf("%c ", arr[i]);
    }
    start = clock();
    insertionSort(arr, size);
    end = clock();
    printf("\n");
    for (int i = 0; i &lt; size; i++) {
        printf("%c ", arr[i]);
    }
    printf("\nExecuted in %fs\n", (double)(end - start) / CLOCKS_PER_SEC);
    return 0;
}

</pre>
        <pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>

ENTER SIZE OF ARRAY : 5
ENTER ARRAY ELEMENT : b
ENTER ARRAY ELEMENT : a
ENTER ARRAY ELEMENT : d
ENTER ARRAY ELEMENT : c
ENTER ARRAY ELEMENT : e
b a d c e 
a b c d e 
Executed in 0.000002s

</pre>

        <pre class="pre">
    <br>
<b id="sortQ16">16. ENTER A STRING ARRAY FROM THE USER AND PERFORM INSERTION SORT ALGORITHM THROUGH RECURSION. 
    ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</b>

#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#define maxSize 100
// Recursive function to perform insertion sort
void insertionSort(char arr[], int n) {
    // Base case: If array has one element, return
    if (n &lt;= 1)
        return;

    // Sort the first n-1 elements
    insertionSort(arr, n - 1);

    // Insert the last element at its correct position
    char last = arr[n - 1];
    int j = n - 2;

    // Shift elements of arr[0..n-2] that are greater than last
    while (j &gt;= 0 && arr[j] &gt; last) {
        arr[j + 1] = arr[j];
        j--;
    }
    arr[j + 1] = last;
}

int main() {
    char arr[maxSize];
    int size;
    clock_t start, end;
    printf("ENTER SIZE OF ARRAY : ");
    scanf("%d", &size);
    for (int i = 0; i &lt; size; i++) {
        printf("ENTER ARRAY ELEMENT : ");
        fflush(stdin);
        scanf(" %c", &arr[i]); // Added space before %c to consume any newline character
    }
    for (int i = 0; i &lt; size; i++) {
        printf("%c ", arr[i]);
    }
    start = clock();
    insertionSort(arr, size);
    end = clock();
    printf("\n");
    for (int i = 0; i &lt; size; i++) {
        printf("%c ", arr[i]);
    }
    printf("\nExecuted in %fs\n", (double)(end - start) / CLOCKS_PER_SEC);
    return 0;
}
    
</pre>
        <pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>

ENTER SIZE OF ARRAY : 5
ENTER ARRAY ELEMENT : b
ENTER ARRAY ELEMENT : a
ENTER ARRAY ELEMENT : d
ENTER ARRAY ELEMENT : c
ENTER ARRAY ELEMENT : e
b a d c e 
a b c d e 
Executed in 0.000002s

</pre>

        <pre class="pre">
<br>
<b id="sortQ17">17. ENTER A STRING ARRAY FROM THE USER AND PERFORM MERGE SORT ALGORITHM THROUGH ITERATION.
     ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</b>

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#define maxSize 100
void display(char arr[], int size) {
    for (int i = 0; i &lt; size; i++) {
        printf("%c ", arr[i]);
    }
    printf("\n");
}
// Function to merge two subarrays
void merge(char arr[], int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    char L[n1], R[n2];

    // Copy data to temp arrays L[] and R[]
    for (int i = 0; i &lt; n1; i++)
        L[i] = arr[left + i];
    for (int j = 0; j &lt; n2; j++)
        R[j] = arr[mid + 1 + j];

    // Merge the temp arrays back into arr[left..right]
    int i = 0, j = 0, k = left;
    while (i &lt; n1 && j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    // Copy remaining elements of L[], if any
    while (i &lt; n1) {
        arr[k] = L[i];
        i++;
        k++;
    }

    // Copy remaining elements of R[], if any
    while (j &lt; n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}

// Iterative merge sort function
void mergeSort(char arr[], int n) {
    int curr_size;  // For current size of subarrays to be merged
    int left_start; // For picking starting index of left subarray

    // Merge subarrays in bottom up manner
    for (curr_size = 1; curr_size &lt;= n - 1; curr_size = 2 * curr_size) {
        // Pick starting point of different subarrays of current size
        for (left_start = 0; left_start &lt; n - 1; left_start += 2 * curr_size) {
            int mid = left_start + curr_size - 1;
            int right_end = (left_start + 2 * curr_size - 1 &lt; n - 1) ? (left_start + 2 * curr_size - 1) : (n - 1);

            // Merge subarrays arr[left_start...mid] & arr[mid+1...right_end]
            merge(arr, left_start, mid, right_end);
        }
    }
}

int main() {
    char arr[maxSize];
    int size;
    clock_t start, end;
    printf("ENTER SIZE OF ARRAY : ");
    scanf("%d", &size);
    for (int i = 0; i &lt; size; i++) {
        printf("ENTER ARRAY ELEMENT : ");
        fflush(stdin);
        scanf(" %c", &arr[i]); // Added space before %c to consume any newline character
    }
    display(arr, size);
    start = clock();
    mergeSort(arr, size);
    end = clock();
    display(arr, size);
    printf("Executed in %fs\n", (double)(end - start) / CLOCKS_PER_SEC);
    return 0;
}
     
</pre>
        <pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>

ENTER SIZE OF ARRAY : 5
ENTER ARRAY ELEMENT : b
ENTER ARRAY ELEMENT : a
ENTER ARRAY ELEMENT : d
ENTER ARRAY ELEMENT : c
ENTER ARRAY ELEMENT : e
b a d c e 
a b c d e 
Executed in 0.000002s

</pre>

        <pre class="pre">
<br>
<b id="sortQ18">18. ENTER A STRING ARRAY FROM THE USER AND PERFORM MERGE SORT ALGORITHM THROUGH RECURSION.
     ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</b>

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#define maxSize 100
void display(char arr[], int size) {
    for (int i = 0; i &lt; size; i++) {
        printf("%c ", arr[i]);
    }
    printf("\n");
}
// The array is divided into two halves until each sub-array contains a single element (which is inherently sorted).
void merge(char arr1[], int start, int mid, int end) {
    int i = start;
    int j = mid + 1;
    int k;
    char *temp = (char *)calloc(sizeof(char), end - start + 1);
    for (k = 0; k &lt;= (end - start); k++) {
        if ((i &lt;= mid) && (j &lt;= end)) {
            if (arr1[i] &lt;= arr1[j]) {
                temp[k] = arr1[i++];
            } else {
                temp[k] = arr1[j++];
            }
        } else {
            if (i &lt;= mid) {
                temp[k] = arr1[i++];
            } else {
                temp[k] = arr1[j++];
            }
        }
    }
    for (i = start; i &lt;= end; i++) {
        arr1[i] = temp[i - start];
    }
    free(temp);
}
void mergeSort(char arr[maxSize], int start, int end) {
    if (start &gt;= end) {
        return;
    } else {
        int mid = start + ((end - start) / 2);
        mergeSort(arr, start, mid);
        mergeSort(arr, mid + 1, end);
        merge(arr, start, mid, end);
    }
}
int main() {
    char arr[maxSize];
    int size;
    clock_t start, end;
    printf("ENTER SIZE OF ARRAY : ");
    scanf("%d", &size);
    for (int i = 0; i &lt; size; i++) {
        printf("ENTER ARRAY ELEMENT : ");
        fflush(stdin);
        scanf(" %c", &arr[i]); // Added space before %c to consume any newline character
    }
    display(arr, size);
    start = clock();
    mergeSort(arr, 0, size - 1);
    end = clock();
    display(arr, size);
    printf("Executed in %fs\n", (double)(end - start) / CLOCKS_PER_SEC);
    return 0;
}
     
</pre>
        <pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>

ENTER SIZE OF ARRAY : 5
ENTER ARRAY ELEMENT : b
ENTER ARRAY ELEMENT : a
ENTER ARRAY ELEMENT : d
ENTER ARRAY ELEMENT : c
ENTER ARRAY ELEMENT : e
b a d c e 
a b c d e 
Executed in 0.000002s

</pre>

        <pre class="pre">
    <br>
<b id="sortQ19">19. ENTER A STRING ARRAY FROM THE USER AND PERFORM QUICK SORT ALGORITHM THROUGH ITERATION. 
    ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</b>

#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#define maxSize 100
// Function to swap two elements
void swap(char *a, char *b) {
    char temp = *a;
    *a = *b;
    *b = temp;
}

// Partition function for quicksort
int partition(char arr[], int low, int high) {
    char pivot = arr[high];
    int i = (low - 1);

    for (int j = low; j &lt;= high - 1; j++) {
        if (arr[j] &lt; pivot) {
            i++;
            swap(&arr[i], &arr[j]);
        }
    }
    swap(&arr[i + 1], &arr[high]);
    return (i + 1);
}

// Iterative QuickSort function
void quickSort(char arr[], int n) {
    char stack[n];
    int top = -1;

    // Initialize stack with initial values
    stack[++top] = 0;
    stack[++top] = n - 1;

    // Keep popping elements from the stack until it's empty
    while (top &gt;= 0) {
        char high = stack[top--];
        char low = stack[top--];

        int pivot = partition(arr, low, high);

        // If there are elements on the left side of the pivot, push left side to stack
        if (pivot - 1 &gt; low) {
            stack[++top] = low;
            stack[++top] = pivot - 1;
        }

        // If there are elements on the right side of the pivot, push right side to stack
        if (pivot + 1 &lt; high) {
            stack[++top] = pivot + 1;
            stack[++top] = high;
        }
    }
}

// Function to print an array
void display(char arr[], int size) {
    for (char i = 0; i &lt; size; i++) {
        printf("%c ", arr[i]);
    }
    printf("\n");
}
int main() {
    char arr[maxSize];
    int size;
    clock_t start, end;
    printf("ENTER SIZE OF ARRAY : ");
    scanf("%d", &size);
    for (int i = 0; i &lt; size; i++) {
        printf("ENTER ARRAY ELEMENT : ");
        fflush(stdin);
        scanf(" %c", &arr[i]); // Added space before %c to consume any newline character
    }
    display(arr, size);
    start = clock();
    quickSort(arr, size);
    end = clock();
    display(arr, size);
    printf("Executed in %fs\n", (double)(end - start) / CLOCKS_PER_SEC);
    return 0;
}

</pre>
        <pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>

ENTER SIZE OF ARRAY : 5
ENTER ARRAY ELEMENT : b
ENTER ARRAY ELEMENT : a
ENTER ARRAY ELEMENT : d
ENTER ARRAY ELEMENT : c
ENTER ARRAY ELEMENT : e
b a d c e 
a b c d e 
Executed in 0.000002s

</pre>

        <pre class="pre">
    <br>
<b id="sortQ20">20. ENTER A STRING ARRAY FROM THE USER AND PERFORM QUICK SORT ALGORITHM THROUGH RECURSION.
     ALSO CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</b>

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#define maxSize 100
void display(char arr[], int size) {
    for (int i = 0; i &lt; size; i++) {
        printf("%c ", arr[i]);
    }
    printf("\n");
}
int partition(char arr[], int start, int end) {
    char pivot = arr[start];
    int ind = start, temp;
    int i = start, j = end;
    for (int i = start; i &lt;= end; i++) {
        if (arr[i] &lt; pivot)
            ind++;
    }
    temp = arr[ind];
    arr[ind] = arr[start];
    arr[start] = temp;
    while ((i &lt; ind) &amp;&amp; (j &gt; ind)) {
        if (arr[i] &gt; pivot) {
            if (arr[j] &lt; pivot) {
                temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            } else
                j--;
        } else
            i++;
    }
    return ind;
}
void quickSort(char arr[maxSize], int start, int end) {
    if (start &gt;= end) {
        return;
    } else {
        int p = partition(arr, start, end);
        quickSort(arr, start, p - 1);
        quickSort(arr, p + 1, end);
    }
}
int main() {
    char arr[maxSize];
    int size;
    clock_t start, end;
    printf("ENTER SIZE OF ARRAY : ");
    scanf("%d", &size);
    for (int i = 0; i &lt; size; i++) {
        printf("ENTER ARRAY ELEMENT : ");
        fflush(stdin);
        scanf(" %c", &arr[i]); // Added space before %c to handle newline characters
    }
    display(arr, size);
    start = clock();
    quickSort(arr, 0, size - 1);
    end = clock();
    display(arr, size);
    printf("Executed in %fs\n", (double)(end - start) / CLOCKS_PER_SEC);
    return 0;
}

</pre>
<pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>

ENTER SIZE OF ARRAY : 5
ENTER ARRAY ELEMENT : b
ENTER ARRAY ELEMENT : a
ENTER ARRAY ELEMENT : d
ENTER ARRAY ELEMENT : c
ENTER ARRAY ELEMENT : e
b a d c e 
a b c d e 
Executed in 0.000002s

</pre>

    </div>
    <button class="back-to-top" id="backToTopBtn">Back to Top</button>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script>
        hljs.highlightAll();

        // Get the button
        const backToTopBtn = document.getElementById("backToTopBtn");

        // Show or hide the button based on scroll position
        window.onscroll = function () {
            if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
                backToTopBtn.style.display = "block";
            } else {
                backToTopBtn.style.display = "none";
            }
        };

        // Scroll to the top when the button is clicked
        backToTopBtn.onclick = function () {
            document.body.scrollTop = 0; // For Safari
            document.documentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
        };
    </script>
</body>

</html>