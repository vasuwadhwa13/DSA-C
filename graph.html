<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph</title>
    <style>
        /* General reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            /* Same background color */
            color: #33334d;
            /* Dark text color */
        }

        .container {
            display: flex;
            min-height: 100vh;
        }

        /* Navigation Bar (on the left side) */
        .navbar {
            width: 250px;
            background-color: #33334d;
            /* Preferred dark color */
            padding: 20px;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            overflow-y: auto;
            position: fixed;
            /* Keep navbar fixed to the left */
            height: 100vh;
            /* Full height to fill the left side */
        }

        .navlist {
            list-style: none;
            padding: 0;
        }

        .navlist li {
            margin: 10px 0;
        }

        .navlist a {
            text-decoration: none;
            color: #ceb040;
            /* Gold text */
            font-weight: bold;
            font-size: 18px;
            padding: 10px;
            display: block;
            transition: background-color 0.3s ease;
        }

        .navlist a:hover {
            background-color: #6d5c6a;
            /* Soft purple hover effect */
            color: #f4f4f4;
        }

        /* Main content */
        .main-content {
            flex-grow: 1;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }

        .box-main {
            max-width: 800px;
            width: 100%;
            margin-left: 170px;
            background-color: #fff;
            /* White background for the box */
            padding: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            border: 2px solid #ceb040;
            /* Gold border */
        }

        .firsthalf2 ul {
            list-style: none;
        }

        .firsthalf2 li {
            margin: 10px 0;
        }

        .firsthalf2 a {
            text-decoration: none;
            font-size: 16px;
            color: #6d5c6a;
            font-family: 'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif;
            /* Soft purple color */
        }

        .firsthalf2 a:hover {
            color: #ceb040;
            /* Gold on hover */
        }

        .vasu {
            color: rgb(14, 13, 13);
            margin-left: 300px;
            max-width: 1000px;
            font-size: large;
            width: auto;
            background-color: #fff;
            /* White background for the box */
            padding: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            border: 4px solid #ceb040;
            word-wrap: break-word;
        }

        .vasu pre {
            word-wrap: break-word;
            white-space: pre-wrap;
            overflow-x: auto;
            padding: 10px;
            margin-bottom: 20px;
        }

        .vasu b {
            font-family: Arial, Helvetica, sans-serif;
            color: #ceb040;
        }

        .out {
            color: #fff;
            background-color: #111111;
        }

        .back-to-top {
            position: fixed;
            bottom: 20px;
            right: 10px;
            background-color: #ceb040;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 10px 15px;
            cursor: pointer;
            display: none;
            /* Hidden by default */
            z-index: 1000;
            /* On top of other elements */
        }

        .back-to-top:hover {
            background-color: #6d5c6a;
        }
    </style>
</head>

<body>
    <div class="container">
        <!-- Left Navigation Bar -->
        <nav class="navbar">
            <ul class="navlist">
                <li><a href="index.html">Home</a></li>
                <li><a href="2Darray.html">2D Array</a></li>
                <li><a href="graph.html">Graph</a></li>
                <li><a href="linkedlist.html">Linked List</a></li>
                <li><a href="queue.html">Queue</a></li>
                <li><a href="rec.html">Recursion</a></li>
                <li><a href="searching.html">Searching Algorithm</a></li>
                <li><a href="array.html">Single Dimension Array</a></li>
                <li><a href="sorting.html">Sorting Algorithm</a></li>
                <li><a href="stack.html">Stack</a></li>
                <li><a href="String.html">Strings</a></li>
                <li><a href="tree.html">Tree</a></li>
            </ul>
        </nav>

        <!-- Right Main Content -->
        <section class="main-content">
            <div class="box-main">
                <h1>GRAPH:- </h1> <!-- Added a heading for context -->
                <div class="firsthalf2">
                    <ul>
                        <li><a href="#Graph1">1. ENTER THE VERTICES AND EDGES AND REPRESENT IN ADJACENCY MATRIX AND
                                PRINT IT ?</a></li>
                        <li><a href="#Graph2">2. CREATE THE GRAPH AS A ADJACENCY LIST WITH OPERATIONS SUCH AS INSERTION,
                                DELETION ?</a></li>
                        <li><a href="#Graph3">3. TRAVERSE THE ADJACENT MATRIX WITH DEPTH FIRST SEARCH ?</a></li>
                        <li><a href="#Graph4">4. TRAVERSE THE ADJACENT LIST WITH DEPTH FIRST SEARCH ?</a></li>
                        <li><a href="#Graph5">5. TRAVERSE THE ADJACENT MATRIX WITH BREADTH FIRST SEARCH ?</a></li>
                        <li><a href="#Graph6">6. TRAVERSE THE ADJACENT LIST WITH BREADTH FIRST SEARCH ?</a></li>

                    </ul>
                </div>
            </div>
        </section>
    </div>
<div class="vasu">
    <pre>
<br>
<b id="Graph1">1. ENTER THE VERTICES AND EDGES AND REPRESENT IN ADJACENCY MATRIX AND PRINT IT ?</b> 

#include &lt;stdio.h&gt;

int main() {
int vertices, edges;

printf("Enter the number of vertices in the graph: ");
scanf("%d", &vertices);

printf("Enter the number of edges in the graph: ");
scanf("%d", &edges);

int adjacencyMatrix[vertices][vertices];

for (int i = 0; i &lt; vertices; i++) {
    for (int j = 0; j &lt; vertices; j++) {
        adjacencyMatrix[i][j] = 0;
    }
}

for (int i = 0; i &lt; edges; i++) {
    int source, destination;
    printf("Enter edge %d (source destination): ", i + 1);
    scanf("%d %d", &source, &destination);

    if (source &gt;= 0 && source &lt; vertices && destination &gt;= 0 && destination &lt; vertices) {
        adjacencyMatrix[source][destination] = 1;
        adjacencyMatrix[destination][source] = 1;
    } else {
        printf("Invalid vertex indices. Please enter valid indices.\n");
        i--;
    }
}

printf("Adjacency Matrix:\n");
for (int i = 0; i &lt; vertices; i++) {
    for (int j = 0; j &lt; vertices; j++) {
        printf("%d ", adjacencyMatrix[i][j]);
    }
    printf("\n");
}

return 0;
}

</pre>
    <pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>

Enter the number of vertices in the graph: 3
Enter the number of edges in the graph: 3
Enter edge 1 (source destination): 0 1
Enter edge 2 (source destination): 1 2
Enter edge 3 (source destination): 0 2
Adjacency Matrix:
0 1 1 
1 0 1 
1 1 0 
    

</pre>

    <pre>
<br>
<b id="Graph2">2. CREATE THE GRAPH AS A ADJACENCY LIST WITH OPERATIONS SUCH AS INSERTION, DELETION ?</b> 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct Node {
int data;
struct Node* next;
};

struct Graph {
int V;
struct Node** adjList;
};

struct Node* createNode(int data) {
struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
newNode-&gt;data = data;
newNode-&gt;next = NULL;
return newNode;
}

struct Graph* createGraph(int V) {
struct Graph* graph = (struct Graph*)malloc(sizeof(struct Graph));
graph-&gt;V = V;
graph-&gt;adjList = (struct Node**)malloc(V * sizeof(struct Node*));

for (int i = 0; i &lt; V; i++) {
    graph-&gt;adjList[i] = NULL;
}

return graph;
}

void addEdge(struct Graph* graph, int src, int dest) {
struct Node* newNode = createNode(dest);
newNode-&gt;next = graph-&gt;adjList[src];
graph-&gt;adjList[src] = newNode;

newNode = createNode(src);
newNode-&gt;next = graph-&gt;adjList[dest];
graph-&gt;adjList[dest] = newNode;
}

void deleteEdge(struct Graph* graph, int src, int dest) {
struct Node* current = graph-&gt;adjList[src];
struct Node* prev = NULL;

while (current != NULL && current-&gt;data != dest) {
    prev = current;
    current = current-&gt;next;
}

if (current == NULL) {
    return;
}

if (prev == NULL) {
    graph-&gt;adjList[src] = current-&gt;next;
} else {
    prev-&gt;next = current-&gt;next;
}

free(current);

current = graph-&gt;adjList[dest];
prev = NULL;

while (current != NULL && current-&gt;data != src) {
    prev = current;
    current = current-&gt;next;
}

if (prev == NULL) {
    graph-&gt;adjList[dest] = current-&gt;next;
} else {
    prev-&gt;next = current-&gt;next;
}

free(current);
}

void displayGraph(struct Graph* graph) {
for (int i = 0; i &lt; graph-&gt;V; i++) {
    struct Node* current = graph-&gt;adjList[i];
    printf("Adjacency list of vertex %d: ", i);
    while (current != NULL) {
        printf("%d -&gt; ", current-&gt;data);
        current = current-&gt;next;
    }
    printf("NULL\n");
}
}

int main() {
int V, E;

printf("Enter the number of vertices: ");
scanf("%d", &V);

struct Graph* graph = createGraph(V);

printf("Enter the number of edges: ");
scanf("%d", &E);

for (int i = 0; i &lt; E; i++) {
    int src, dest;
    printf("Enter edge %d (source destination): ", i + 1);
    scanf("%d %d", &src, &dest);
    addEdge(graph, src, dest);
}

printf("Graph before deletion:\n");
displayGraph(graph);

int src, dest;
printf("Enter edge to delete (source destination): ");
scanf("%d %d", &src, &dest);
deleteEdge(graph, src, dest);

printf("Graph after deletion:\n");
displayGraph(graph);

return 0;
}


</pre>
    <pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>

Enter the number of vertices: 4
Enter the number of edges: 4
Enter edge 1 (source destination): 0 1
Enter edge 2 (source destination): 0 2
Enter edge 3 (source destination): 1 2
Enter edge 4 (source destination): 2 3
Graph before deletion:
Adjacency list of vertex 0: 2 -&gt; 1 -&gt; NULL
Adjacency list of vertex 1: 2 -&gt; 0 -&gt; NULL
Adjacency list of vertex 2: 3 -&gt; 1 -&gt; 0 -&gt; NULL
Adjacency list of vertex 3: 2 -&gt; NULL
Enter edge to delete (source destination): 0 1
Graph after deletion:
Adjacency list of vertex 0: 2 -&gt; NULL
Adjacency list of vertex 1: NULL
Adjacency list of vertex 2: 3 -&gt; NULL
Adjacency list of vertex 3: 2 -&gt; NULL

        
</pre>

    <pre>
<br>
<b id="Graph3">3. TRAVERSE THE ADJACENT MATRIX WITH DEPTH FIRST SEARCH ?</b>

#include &lt;stdio.h&gt;

void depthFirstSearch(int vertex, int V, int adjacencyMatrix[V][V], int visited[]) {
printf("%d ", vertex);
visited[vertex] = 1;

for (int i = 0; i &lt; V; i++) {
    if (adjacencyMatrix[vertex][i] == 1 && !visited[i]) {
        depthFirstSearch(i, V, adjacencyMatrix, visited);
    }
}
}

int main() {
int V;

printf("Enter the number of vertices: ");
scanf("%d", &V);

int adjacencyMatrix[V][V];

printf("Enter the adjacency matrix (%d x %d):\n", V, V);
for (int i = 0; i &lt; V; i++) {
    for (int j = 0; j &lt; V; j++) {
        scanf("%d", &adjacencyMatrix[i][j]);
    }
}

int visited[V];
for (int i = 0; i &lt; V; i++) {
    visited[i] = 0;
}

printf("Enter the starting vertex for DFS: ");
int startVertex;
scanf("%d", &startVertex);

printf("Depth-First Search Traversal starting from vertex %d: ", startVertex);
depthFirstSearch(startVertex, V, adjacencyMatrix, visited);
printf("\n");

return 0;
}


    </pre>
    <pre class="out">
<h3 style="text-align: center;">OUTPUT</h3> 
    
Enter the number of vertices: 4
Enter the adjacency matrix (4 x 4):
0 1 0 1
1 0 1 0
0 1 0 0
1 0 0 0
Enter the starting vertex for DFS: 0
Depth-First Search Traversal starting from vertex 0: 0 1 2 3 

</pre>

    <pre>
<br>
<b id="Graph4">4. TRAVERSE THE ADJACENT LIST WITH DEPTH FIRST SEARCH ?</b> 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct Node {
int data;
struct Node* next;
};

struct Graph {
int V;
struct Node** adjList;
};

struct Node* createNode(int data) {
struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
newNode->data = data;
newNode->next = NULL;
return newNode;
}

struct Graph* createGraph(int V) {
struct Graph* graph = (struct Graph*)malloc(sizeof(struct Graph));
graph->V = V;
graph->adjList = (struct Node**)malloc(V * sizeof(struct Node*));

for (int i = 0; i &lt; V; i++) {
    graph->adjList[i] = NULL;
}

return graph;
}

void addEdge(struct Graph* graph, int src, int dest) {
struct Node* newNode = createNode(dest);
newNode-&gt;next = graph->adjList[src];
graph->adjList[src] = newNode;

newNode = createNode(src);
newNode-&gt;next = graph->adjList[dest];
graph->adjList[dest] = newNode;
}

void depthFirstSearch(struct Graph* graph, int vertex, int visited[]) {
visited[vertex] = 1;
printf("%d ", vertex);

struct Node* current = graph->adjList[vertex];
while (current != NULL) {
    if (!visited[current->data]) {
        depthFirstSearch(graph, current->data, visited);
    }
    current = current->next;
}
}

int main() {
int V, E;

printf("Enter the number of vertices: ");
scanf("%d", &V);

struct Graph* graph = createGraph(V);

printf("Enter the number of edges: ");
scanf("%d", &E);

for (int i = 0; i &lt; E; i++) {
    int src, dest;
    printf("Enter edge %d (source destination): ", i + 1);
    scanf("%d %d", &src, &dest);
    addEdge(graph, src, dest);
}

printf("Enter the starting vertex for DFS: ");
int startVertex;
scanf("%d", &startVertex);

int visited[V];
for (int i = 0; i &lt; V; i++) {
    visited[i] = 0;
}

printf("Depth-First Search Traversal starting from vertex %d: ", startVertex);
depthFirstSearch(graph, startVertex, visited);
printf("\n");

return 0;
}


    </pre>
    <pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>
    
Enter the number of vertices: 5
Enter the number of edges: 4
Enter edge 1 (source destination): 0 1
Enter edge 2 (source destination): 0 4
Enter edge 3 (source destination): 1 3
Enter edge 4 (source destination): 1 2
Enter the starting vertex for DFS: 0
Depth-First Search Traversal starting from vertex 0: 0 1 3 2 4 

</pre>

    <pre>
<br>
<b id="Graph5">5. TRAVERSE THE ADJACENT MATRIX WITH BREADTH FIRST SEARCH ?</b> 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void breadthFirstSearch(int startVertex, int V, int adjacencyMatrix[V][V], int visited[]) {
int queue[V];
int front = -1, rear = -1;

printf("Breadth-First Search Traversal starting from vertex %d: ", startVertex);

visited[startVertex] = 1;
queue[++rear] = startVertex;

while (front != rear) {
    int currentVertex = queue[++front];
    printf("%d ", currentVertex);

    for (int i = 0; i &lt; V; i++) {
        if (adjacencyMatrix[currentVertex][i] == 1 && !visited[i]) {
            visited[i] = 1;
            queue[++rear] = i;
        }
    }
}

printf("\n");
}

int main() {
int V;

printf("Enter the number of vertices: ");
scanf("%d", &V);

int adjacencyMatrix[V][V];

printf("Enter the adjacency matrix (%d x %d):\n", V, V);
for (int i = 0; i &lt; V; i++) {
    for (int j = 0; j &lt; V; j++) {
        scanf("%d", &adjacencyMatrix[i][j]);
    }
}

int visited[V];
for (int i = 0; i &lt; V; i++) {
    visited[i] = 0;
}

int startVertex;
printf("Enter the starting vertex for BFS: ");
scanf("%d", &startVertex);

breadthFirstSearch(startVertex, V, adjacencyMatrix, visited);

return 0;
}


    </pre>
    <pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>  

Enter the number of vertices: 5
Enter the adjacency matrix (5 x 5):
0 1 0 0 1
1 0 1 1 0
0 1 0 0 0
0 1 0 0 0
1 0 0 0 0
Enter the starting vertex for BFS: 0
Breadth-First Search Traversal starting from vertex 0: 0 1 4 2 3 


</pre>

    <pre>
<br>
<b id="Graph6">6. TRAVERSE THE ADJACENT LIST WITH BREADTH FIRST SEARCH ?</b>

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct Node {
int data;
struct Node* next;
};

struct Graph {
int V;
struct Node** adjList;
};

struct Node* createNode(int data) {
struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
newNode->data = data;
newNode->next = NULL;
return newNode;
}

struct Graph* createGraph(int V) {
struct Graph* graph = (struct Graph*)malloc(sizeof(struct Graph));
graph->V = V;
graph->adjList = (struct Node**)malloc(V * sizeof(struct Node*));

for (int i = 0; i &lt; V; i++) {
    graph->adjList[i] = NULL;
}

return graph;
}

void addEdge(struct Graph* graph, int src, int dest) {
struct Node* newNode = createNode(dest);
newNode-&gt;next = graph->adjList[src];
graph->adjList[src] = newNode;

newNode = createNode(src);
newNode-&gt;next = graph->adjList[dest];
graph->adjList[dest] = newNode;
}

void breadthFirstSearch(struct Graph* graph, int startVertex, int visited[]) {
int queue[graph->V];
int front = -1, rear = -1;

printf("Breadth-First Search Traversal starting from vertex %d: ", startVertex);

visited[startVertex] = 1;
queue[++rear] = startVertex;

while (front != rear) {
    int currentVertex = queue[++front];
    printf("%d ", currentVertex);

    struct Node* current = graph->adjList[currentVertex];
    while (current != NULL) {
        if (!visited[current->data]) {
            visited[current->data] = 1;
            queue[++rear] = current->data;
        }
        current = current-&gt;next;
    }
}

printf("\n");
}

int main() {
int V, E;

printf("Enter the number of vertices: ");
scanf("%d", &V);

struct Graph* graph = createGraph(V);

printf("Enter the number of edges: ");
scanf("%d", &E);

for (int i = 0; i &lt; E; i++) {
    int src, dest;
    printf("Enter edge %d (source destination): ", i + 1);
    scanf("%d %d", &src, &dest);
    addEdge(graph, src, dest);
}

int visited[V];
for (int i = 0; i &lt; V; i++) {
    visited[i] = 0;
}

int startVertex;
printf("Enter the starting vertex for BFS: ");
scanf("%d", &startVertex);

breadthFirstSearch(graph, startVertex, visited);

return 0;
}


    </pre>
    <pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>  

Enter the number of vertices: 5
Enter the number of edges: 4
Enter edge 1 (source destination): 0 1
Enter edge 2 (source destination): 0 4
Enter edge 3 (source destination): 1 2
Enter edge 4 (source destination): 1 3
Enter the starting vertex for BFS: 0
Breadth-First Search Traversal starting from vertex 0: 0 1 4 2 3 


</pre>

</div>

    <button class="back-to-top" id="backToTopBtn">Back to Top</button>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script>
        hljs.highlightAll();

        // Get the button
        const backToTopBtn = document.getElementById("backToTopBtn");

        // Show or hide the button based on scroll position
        window.onscroll = function () {
            if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
                backToTopBtn.style.display = "block";
            } else {
                backToTopBtn.style.display = "none";
            }
        };

        // Scroll to the top when the button is clicked
        backToTopBtn.onclick = function () {
            document.body.scrollTop = 0; // For Safari
            document.documentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
        };
    </script>
</body>

</html>