<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STACK</title>
    <style>
        /* General reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            /* Same background color */
            color: #33334d;
            /* Dark text color */
        }

        .container {
            display: flex;
            min-height: 100vh;
        }

        /* Navigation Bar (on the left side) */
        .navbar {
            width: 250px;
            background-color: #33334d;
            /* Preferred dark color */
            padding: 20px;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            overflow-y: auto;
            position: fixed;
            /* Keep navbar fixed to the left */
            height: 100vh;
            /* Full height to fill the left side */
        }

        .navlist {
            list-style: none;
            padding: 0;
        }

        .navlist li {
            margin: 10px 0;
        }

        .navlist a {
            text-decoration: none;
            color: #ceb040;
            /* Gold text */
            font-weight: bold;
            font-size: 18px;
            padding: 10px;
            display: block;
            transition: background-color 0.3s ease;
        }

        .navlist a:hover {
            background-color: #6d5c6a;
            /* Soft purple hover effect */
            color: #f4f4f4;
        }

        /* Main content */
        .main-content {
            flex-grow: 1;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }

        .box-main {
            max-width: 800px;
            margin-left: 170px;
            width: 100%;
            background-color: #fff;
            /* White background for the box */
            padding: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            border: 2px solid #ceb040;
            /* Gold border */
        }

        .firsthalf2 ul {
            list-style: none;
        }

        .firsthalf2 li {
            margin: 10px 0;
        }

        .firsthalf2 a {
            text-decoration: none;
            font-size: 16px;
            color: #6d5c6a;
            font-family: 'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif;
            /* Soft purple color */
        }

        .firsthalf2 a:hover {
            color: #ceb040;
            /* Gold on hover */
        }

        .vasu {
            color: rgb(14, 13, 13);
            margin-left: 300px;
            max-width: 1000px;
            font-size: large;
            width: auto;
            background-color: #fff;
            /* White background for the box */
            padding: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            border: 4px solid #ceb040;
            word-wrap: break-word;
        }

        .vasu b {
            font-family: Arial, Helvetica, sans-serif;
            color: #ceb040;
        }

        .out {
            color: #fff;
            background-color: #111111;
        }

        .back-to-top {
            position: fixed;
            bottom: 20px;
            right: 10px;
            background-color: #ceb040;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 10px 15px;
            cursor: pointer;
            display: none;
            /* Hidden by default */
            z-index: 1000;
            /* On top of other elements */
        }

        .back-to-top:hover {
            background-color: #6d5c6a;
        }
    </style>
</head>

<body>
    <div class="container">
        <!-- Left Navigation Bar -->
        <nav class="navbar">
            <ul class="navlist">
                <li><a href="index.html">Home</a></li>
                <li><a href="2Darray.html">2D Array</a></li>
                <li><a href="graph.html">Graph</a></li>
                <li><a href="linkedlist.html">Linked List</a></li>
                <li><a href="queue.html">Queue</a></li>
                <li><a href="rec.html">Recursion</a></li>
                <li><a href="searching.html">Searching Algorithm</a></li>
                <li><a href="array.html">Single Dimension Array</a></li>
                <li><a href="sorting.html">Sorting Algorithm</a></li>
                <li><a href="stack.html">Stack</a></li>
                <li><a href="String.html">Strings</a></li>
                <li><a href="tree.html">Tree</a></li>
            </ul>
        </nav>

        <!-- Right Main Content -->
        <section class="main-content">
            <div class="box-main">
                <h1>Stack Questions:</h1> <!-- Added a heading for context -->
                <div class="firsthalf2">
                    <ul>
                        <li><a href="#stQ1">1.CREATE A STACK IMPLEMENTING THE OPERATIONS ON AN INTEGER ARRAY (PUSH, POP,
                                PEEK, ISEMPTY, ISFULL)</a></li>
                        <li><a href="#stQ2">2.CREATE A STACK IMPLEMENTING THE OPERATIONS ON THE CHARACTERS ARRAY (PUSH,
                                POP, PEEK, ISEMPTY, ISFULL)</a></li>
                        <li><a href="#stQ3">3.CREATE A STACK IMPLEMENTING THE OPERATIONS ON AN INTEGER NODES
                                (DYNAMICALLY) (PUSH, POP, PEEK, ISEMPTY, ISFULL)</a></li>
                        <li><a href="#stQ4">4.CREATE A STACK IMPLEMENTING THE OPERATIONS ON THE CHARACTERS NODES
                                (DYNAMICALLY) (PUSH, POP, PEEK, ISEMPTY, ISFULL)</a></li>
                        <li><a href="#stQ5">5.ENTER THE STRING FROM THE USER AND REVERSE THE STRING USING STACKS.</a>
                        </li>
                        <li><a href="#stQ6">6.CREATE THE PROGRAM TO MATCH THE SINGLE BRACKET USING STACKS.</a></li>
                        <li><a href="#stQ7">7.CREATE TWO INTEGER STACKS IN A SINGLE ARRAY.</a></li>
                        <li><a href="#stQ8">8.SORT THE STACK IN ASCENDING ORDER USING INTEGER ARRAY.</a></li>
                        <li><a href="#stQ9">9.ENTER THE INFIX EXPRESSION FROM USER AND CONVERT INTO PREFIX
                                EXPRESSION.</a></li>
                        <li><a href="#stQ10">10.ENTER THE INFIX EXPRESSION FROM USER AND CONVERT INTO POSTFIX
                                EXPRESSION.</a></li>
                        <li><a href="#stQ11">11.CREATE A PROGRAM TO EVALUATE THE PREFIX EXPRESSION.</a></li>
                        <li><a href="#stQ12">12.CREATE A PROGRAM TO EVALUATE THE POSTFIX EXPRESSION.</a></li>
                        <li><a href="#stQ13">13.IMPLEMENT THE TOWER OF HANOI USING STACKS.</a></li>
                    </ul>
                </div>
            </div>
        </section>
    </div>
    <div class="vasu">

        <pre>
<br>
<b id="stQ1">1. CREATE A STACK IMPLEMENTING THE OPERATIONS ON AN INTEGER ARRAY 
(PUSH, POP, PEEK, ISEMPTY, ISFULL)</b>

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int top = -1;
void push(int *stack, int size)
{
    int item;
    if (top == size - 1)
    {
        printf("!OVERFLOW");
        return;
    }
    
    printf("\nEnter the item: ");
    scanf("%d", &item);
    
    top++;
    stack[top] = item;
    printf("The item %d inserted at index stack[%d]", item, top);    
}

void pop(int *stack, int size)
{
    if (top == -1)
    {
        printf("!UNDERFLOW");
        return;    
    }    
    
    else
    {
        printf("The item %d at stack[%d] is popped.", stack[top], top);
        stack[top] = 0;
        top--;
    }
}

void peek(int *stack, int size)
{
    if (top == -1)
    {
        printf("UNDERFLOW!");
        return;
    }
    printf("\nThe top most item is %d at index stack[%d]", stack[top], top);
}

void isempty()
{
    if (top == -1) 
    {
        printf("Stack is empty.\n");
    } 
    else 
    {
        printf("Stack is not empty.\n");
    }    
}

void isfull(int size)
{
    if (top == size - 1) 
    {
        printf("Stack is full.\n");
    } 
    else 
    {
        printf("Stack is not full.\n");
    }
}

void main()
{
    int stack[5];
    int choice;
    while (1)
    {
        printf("\nEnter the 1 for push ():");    
        printf("\nEnter the 2 for pop ():");
        printf("\nEnter the 3 for peek ():");
        printf("\nEnter the 4 for isempty ():");
        printf("\nEnter the 5 for isfull ():");
        printf("\nEnter the 6 for exit ():");
        printf("\nEnter the choice : ");
        scanf("%d", &choice);
        switch (choice)
        {
            case 1:
                push(stack, 5);
                break;
            case 2:
                pop(stack, 5);
                break;
            case 3:
                peek(stack, 5);
                break;        
            case 4:
                isempty();
                break;        
            case 5:
                isfull(5);
                break;
            case 6:
                exit(0); 
            default:
                printf("INVALID INPUT");
                break;                
        }
    }
}

</pre>
        <pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>
1. Push
2. Pop
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 1

Enter the item: 10
The item 10 inserted at index stack[0]

1. Push
2. Pop
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 1

Enter the item: 20
The item 20 inserted at index stack[1]

1. Push
2. Pop
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 3
The top most item is 20 at index stack[1]

1. Push
2. Pop
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 4
Stack is not empty.

1. Push
2. Pop
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 5
Stack is not full.

1. Push
2. Pop
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 2
The item 20 at stack[1] is popped.

1. Push
2. Pop
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 3
The top most item is 10 at index stack[0]

1. Push
2. Pop
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 6

</pre>

        <pre>
<br>
<b id="stQ2">2. CREATE A STACK IMPLEMENTING THE OPERATIONS ON THE CHARACTERS ARRAY 
(PUSH, POP, PEEK, ISEMPTY, ISFULL)</b>

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int top = -1;

void push(char *stack, int size) 
{
    char item;
    if (top == size - 1) 
    {
        printf("!OVERFLOW\n");
        return;
    }
    
    printf("\nEnter the item: ");
    scanf(" %c", &item);
    
    top++;
    stack[top] = item;
    printf("The item '%c' inserted at index stack[%d]\n", item, top);
}

void pop(char *stack) 
{
    if (top == -1) 
    {
        printf("!UNDERFLOW\n");
        return;    
    }    
    
    printf("The item '%c' at stack[%d] is popped.\n", stack[top], top);
    stack[top] = 0;
    top--;
}

void peek(char *stack) 
{
    if (top == -1) 
    {
        printf("!UNDERFLOW\n");
        return;
    }
    printf("The top most item is '%c' at index stack[%d]\n", stack[top], top);
}

void isempty() 
{
    if (top == -1) 
    {
        printf("Stack is empty.\n");
    } 
    else 
    {
        printf("Stack is not empty.\n");
    }    
}

void isfull(int size) 
{
    if (top == size - 1) 
    {
        printf("Stack is full.\n");
    } 
    else 
    {
        printf("Stack is not full.\n");
    }
}

int main() 
{
    char stack[5];
    int choice;
    while (1) 
    {
        printf("\n1. Push\n");
        printf("2. Pop\n");
        printf("3. Peek\n");
        printf("4. Check if Empty\n");
        printf("5. Check if Full\n");
        printf("6. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);
        switch (choice) 
        {
            case 1:
                push(stack, 5);
                break;
            case 2:
                pop(stack);
                break;
            case 3:
                peek(stack);
                break;        
            case 4:
                isempty();
                break;        
            case 5:
                isfull(5);
                break;        
            case 6:
                exit(0); 
            default:
                printf("INVALID INPUT\n");
                break;                
        }
    }
    return 0;
}

</pre>
        <pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>
1. Push
2. Pop
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 1

Enter the item:
a
The item 'a' inserted at index stack[0]

1. Push
2. Pop
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 4
Stack is not empty.

1. Push
2. Pop
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 5
Stack is not full.

1. Push
2. Pop
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 2
The item 'a' at stack[0] is popped.

1. Push
2. Pop
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 3
!UNDERFLOW
</pre>

        <pre>
<br>
<b id="stQ3">3. CREATE A STACK IMPLEMENTING THE OPERATIONS ON AN INTEGER NODES (DYNAMICALLY) 
(PUSH, POP, PEEK, ISEMPTY, ISFULL)</b>

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct stack {
    int max;
    int top;
    int *array;
};

struct stack s1;

void inti() { 
    printf("\nEnter the max (size of the array): ");
    scanf("%d", &s1.max);
    s1.array = (int *)malloc(sizeof(int) * s1.max);
    s1.top = -1;
    printf("\nThe stack is created. Insert the items.");
}

void push() {
    int item;
    if (s1.top == s1.max - 1) {
        printf("\nThe stack is overflow");
        return;
    }
    printf("\nEnter the item to insert: ");
    scanf("%d", &item);
    s1.top++;
    s1.array[s1.top] = item;
    printf("\nThe item %d is inserted at arr[%d] index", item, s1.top);
}

void pop() {
    int i;
    if (s1.top == -1) {
        printf("Underflow stack");
        return;
    }
    s1.array[s1.top] = 0;
    for (i = s1.top; i >= 0; i--) {
        printf("%d\t", s1.array[i]);
    } 
    s1.top--;
    printf("The item is popped from the stack");
}

void peak() {
    if (s1.top == -1) {
        printf("Underflow stack");
        return;
    }
    printf("The top item %d in the stack is at arr[%d]", s1.array[s1.top], s1.top);
}

void isempty() {
    if (s1.top == -1) {
        printf("Stack is empty.\n");
    } else {
        printf("Stack is not empty.\n");
    }
}

void isfull() {
    if (s1.top == s1.max - 1) {
        printf("Stack is full.\n");
    } else {
        printf("Stack is not full.\n");
    }
}

int main() {
    int choice;
    while (1) {
        printf("\n1. Initialize Stack");
        printf("\n2. Push");
        printf("\n3. Pop");
        printf("\n4. Peek");
        printf("\n5. Is Empty");
        printf("\n6. Is Full");
        printf("\n7. Exit");
        printf("\n\nEnter the choice: ");
        scanf("%d", &choice);
        switch (choice) {
            case 1: inti(); break;
            case 2: push(); break;
            case 3: pop(); break;
            case 4: peak(); break;
            case 5: isempty(); break;
            case 6: isfull(); break;
            case 7: exit(0);
            default: printf("INVALID INPUT\n"); break;
        }
    }
    return 0;
}

</pre>
        <pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>
1. Initialize Stack
2. Push
3. Pop
4. Peek
5. Is Empty
6. Is Full
7. Exit

Enter the choice: 1

Enter the max (size of the array): 5
The stack is created. Insert the items.

1. Initialize Stack
2. Push
3. Pop
4. Peek
5. Is Empty
6. Is Full
7. Exit

Enter the choice: 2

Enter the item to insert: 10
The item 10 is inserted at arr[0] index

1. Initialize Stack
2. Push
3. Pop
4. Peek
5. Is Empty
6. Is Full
7. Exit

Enter the choice: 2

Enter the item to insert: 20
The item 20 is inserted at arr[1] index

1. Initialize Stack
2. Push
3. Pop
4. Peek
5. Is Empty
6. Is Full
7. Exit

Enter the choice: 4

The top item 20 in the stack is at arr[1]

1. Initialize Stack
2. Push
3. Pop
4. Peek
5. Is Empty
6. Is Full
7. Exit

Enter the choice: 3

The item is popped from the stack
10	20	

1. Initialize Stack
2. Push
3. Pop
4. Peek
5. Is Empty
6. Is Full
7. Exit

Enter the choice: 5

Stack is not empty.

1. Initialize Stack
2. Push
3. Pop
4. Peek
5. Is Empty
6. Is Full
7. Exit

Enter the choice: 6

Stack is not full.

1. Initialize Stack
2. Push
3. Pop
4. Peek
5. Is Empty
6. Is Full
7. Exit

Enter the choice: 7

</pre>

        <pre>
<br>
<b id="stQ4">4. CREATE A STACK IMPLEMENTING THE OPERATIONS ON THE CHARACTERS NODES 
(DYNAMICALLY) (PUSH, POP, PEEK, ISEMPTY, ISFULL)</b>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct stack {
    int max;
    int top;
    char *array;
};

struct stack s1;

void inti() { 
    printf("\nEnter the max (size of the array): ");
    scanf("%d", &s1.max);
    s1.array = (char *)malloc(sizeof(char) * s1.max);
    s1.top = -1;
    printf("\nThe stack is created. Insert the items.");
}

void push() {
    char item;
    if (s1.top == s1.max - 1) {
        printf("\nThe stack is overflow");
        return;
    }
    printf("\nEnter the item to insert: ");
    scanf(" %c", &item); // Note the space before %c to consume any newline
    s1.top++;
    s1.array[s1.top] = item;
    printf("\nThe item '%c' is inserted at arr[%d] index", item, s1.top);
}

void pop() {
    if (s1.top == -1) {
        printf("Underflow stack");
        return;
    }
    printf("The item '%c' is popped from the stack", s1.array[s1.top]);
    s1.top--;
}

void peak() {
    if (s1.top == -1) {
        printf("Underflow stack");
        return;
    }
    printf("The top item '%c' in the stack is at arr[%d]", s1.array[s1.top], s1.top);
}

void isempty() {
    if (s1.top == -1) {
        printf("Stack is empty.\n");
    } else {
        printf("Stack is not empty.\n");
    }
}

void isfull() {
    if (s1.top == s1.max - 1) {
        printf("Stack is full.\n");
    } else {
        printf("Stack is not full.\n");
    }
}

int main() {
    int choice;
    while (1) {
        printf("\n1. Initialize Stack");
        printf("\n2. Push");
        printf("\n3. Pop");
        printf("\n4. Peek");
        printf("\n5. Is Empty");
        printf("\n6. Is Full");
        printf("\n7. Exit");
        printf("\n\nEnter the choice: ");
        scanf("%d", &choice);
        switch (choice) {
            case 1: inti(); break;
            case 2: push(); break;
            case 3: pop(); break;
            case 4: peak(); break;
            case 5: isempty(); break;
            case 6: isfull(); break;
            case 7: exit(0);
            default: printf("INVALID INPUT\n"); break;
        }
    }
    return 0;
}

</pre>
        <pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>
1. Initialize Stack
2. Push
3. Pop
4. Peek
5. Is Empty
6. Is Full
7. Exit

Enter the choice: 1

Enter the max (size of the array): 5
The stack is created. Insert the items.

1. Initialize Stack
2. Push
3. Pop
4. Peek
5. Is Empty
6. Is Full
7. Exit

Enter the choice: 2

Enter the item to insert: A
The item 'A' is inserted at arr[0] index

1. Initialize Stack
2. Push
3. Pop
4. Peek
5. Is Empty
6. Is Full
7. Exit

Enter the choice: 2

Enter the item to insert: B
The item 'B' is inserted at arr[1] index

1. Initialize Stack
2. Push
3. Pop
4. Peek
5. Is Empty
6. Is Full
7. Exit

Enter the choice: 4
The top item 'B' in the stack is at arr[1]

1. Initialize Stack
2. Push
3. Pop
4. Peek
5. Is Empty
6. Is Full
7. Exit

Enter the choice: 5
Stack is not empty.

1. Initialize Stack
2. Push
3. Pop
4. Peek
5. Is Empty
6. Is Full
7. Exit

Enter the choice: 3
The item 'B' is popped from the stack

1. Initialize Stack
2. Push
3. Pop
4. Peek
5. Is Empty
6. Is Full
7. Exit

Enter the choice: 4
The top item 'A' in the stack is at arr[0]

1. Initialize Stack
2. Push
3. Pop
4. Peek
5. Is Empty
6. Is Full
7. Exit

Enter the choice: 6
Stack is not full.

1. Initialize Stack
2. Push
3. Pop
4. Peek
5. Is Empty
6. Is Full
7. Exit

Enter the choice: 3
The item 'A' is popped from the stack

1. Initialize Stack
2. Push
3. Pop
4. Peek
5. Is Empty
6. Is Full
7. Exit

Enter the choice: 5
Stack is empty.

1. Initialize Stack
2. Push
3. Pop
4. Peek
5. Is Empty
6. Is Full
7. Exit

Enter the choice: 7
 
</pre>

        <pre>
<br>
<b id="stQ5">5. ENTER THE STRING FROM THE USER AND REVERSE THE STRING USING STACKS.</b>

#include &lt;stdio.h&gt;

struct Node 
{
    char data;
    struct Node* next;
};

struct Node* top = NULL;

void push(char item) 
{
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = item;
    newNode->next = top;
    top = newNode;
}

char pop() 
{
    if (top == NULL) 
    {
        return '\0';
    }
    struct Node* temp = top;
    char data = temp->data;
    top = top->next;
    free(temp);
    return data;
}

int calculateLength(char* str) 
{
    int length = 0;
    while (str[length] != '\0') 
    {
        length++;
    }
    return length;
}

void reverseString(char* str) 
{
    int length = calculateLength(str);
    for (int i = 0; i &lt; length; i++) 
    {
        push(str[i]);
    }
    for (int i = 0; i &lt; length; i++) 
    {
        str[i] = pop();
    }
}

int main() 
{
    char str[100];

    printf("Enter a string: ");
    scanf("%s", str);

    reverseString(str);

    printf("Reversed string: %s\n", str);

    return 0;
}

</pre>
        <pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>
Enter a string: vasu
Reversed string: usav
</pre>

        <pre>
<br>
<b id="stQ6">6. CREATE THE PROGRAM TO MATCH THE SINGLE BRACKET USING STACKS.</b>

#include &lt;stdio.h&gt;

void push(char *exp,int size,char *stack,int ssize) 
{
    int i;
    int j=0;
    for(i=0;exp[i]!='\0';i++) 
    {
        if(exp[i]=='(') 
        {
            stack[j]=exp[i];
            j++;
        }
        else if(exp[i]==')') 
        {
            if(j>0) 
            {
                j--;
            } 
            else 
            {
                printf("brackets are not matched");
            }
        }
    }
    if(j==0) 
    {
        printf("The brackets are matched");
    } 
    else 
    {
        printf("Brackets are not matched");
    }
}

void main() 
{
    char exp[20];
    char stack[20];
    printf("Enter the expression :");
    scanf("%s",exp);
    push(exp,20,stack,20);
}

</pre>
        <pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>
Enter the expression :
()()))())((
The brackets are matched.
</pre>

        <pre>
<br>
<b id="stQ7">7. CREATE TWO INTEGER STACKS IN A SINGLE ARRAY.</b>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define SIZE 10

int array[SIZE];
int top1 = -1;
int top2 = SIZE;

void push1(int data) 
{  
    if (top1 &lt; top2 - 1) 
    {  
        top1++;  
        array[top1] = data;  
    } 
    else 
    {  
        printf("Stack 1 is full\n");  
    }  
}  

void push2(int data) 
{  
    if (top1 &lt; top2 - 1) 
    {  
        top2--;  
        array[top2] = data;   
    } 
    else 
    {  
        printf("Stack 2 is full\n");  
    }  
}  

void display_stack1() 
{  
    printf("Stack 1: ");
    for (int i = top1; i &gt;= 0; --i) 
    {  
        printf("%d ", array[i]);  
    }  
    printf("\n");  
}  

void display_stack2() 
{  
    printf("Stack 2: ");
    for (int i = top2; i &lt; SIZE; ++i) 
    {  
        printf("%d ", array[i]);  
    }  
    printf("\n");  
}  

int main() 
{  
    int i;  
    printf("We can push a total of 20 values\n");  

    for (i = 1; i &lt;= 5; ++i) 
    {  
        push1(i);  
        printf("Value Pushed in Stack 1 is %d\n", i);  
    }  

    for (i = 6; i &lt;= 10; ++i) 
    {  
        push2(i);  
        printf("Value Pushed in Stack 2 is %d\n", i);  
    }  

    display_stack1();  
    display_stack2();  

    printf("Pushing Value in Stack 1 is %d\n", 11);  
    push1(11);  

    return 0;  
}  

</pre>
        <pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>
We can push a total of 10 values
Value Pushed in Stack 1 is 1
Value Pushed in Stack 1 is 2
Value Pushed in Stack 1 is 3
Value Pushed in Stack 1 is 4
Value Pushed in Stack 1 is 5
Value Pushed in Stack 2 is 6
Value Pushed in Stack 2 is 7
Value Pushed in Stack 2 is 8
Value Pushed in Stack 2 is 9
Value Pushed in Stack 2 is 10
Stack 1: 5 4 3 2 1
Stack 2: 10 9 8 7 6
Pushing Value in Stack 1 is 11
Stack 1 is full
</pre>
        <pre>
<br>
<b id="stQ8">8. SORT THE STACK IN ASCENDING ORDER USING INTEGER ARRAY.</b>

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int top = -1;

void push(int *stack, int size) 
{
    int item;
    if (top == size - 1) 
	{
        printf("!OVERFLOW");
        return;
    }

    printf("\nEnter the item: ");
    scanf("%d", &item);

    top++;
    stack[top] = item;
    printf("The item %d inserted at index stack[%d]", item, top);    
}

void pop(int *stack, int size) 
{
    if (top == -1) 
	{
        printf("!UNDERFLOW");
        return;    
    }    
    
    printf("The item %d at stack[%d] is popped.", stack[top], top);
    stack[top] = 0;
    top--;
}

void peek(int *stack, int size) 
{
    if (top == -1) 
	{
        printf("UNDERFLOW!");
        return;
    }
    printf("\nThe top most item is %d at index stack[%d]", stack[top], top);
}

void trav(int *stack, int size)
{
		int i;
		printf("\n The elements present in stack are : ");
		for(i = top; i &gt;= 0; i--)
		{
			printf("%d ", stack[i]);
		}
}	

void sort(int *stack) 
{
    for (int i = 0; i &lt;= top; i++) 
	{
        for (int j = 0; j &lt; top - i; j++) 
		{
            if (stack[j] &lt; stack[j + 1]) 
			{
                int temp = stack[j];
                stack[j] = stack[j + 1];
                stack[j + 1] = temp;
            }
        }
    }
    printf("Stack sorted in ascending order.\n");
}

void main() 
{
    int stack[5];
    int choice;
    while (1) 
	{
        printf("\n1 push():");    
        printf("\n2 pop ():");
        printf("\n3 peek ():");
        printf("\n4 trav ()");
        printf("\n5 sort ():");
        printf("\n6 exit ():");
        printf("\nEnter the choice : ");
        scanf("%d", &choice);
        switch (choice) 
		{
            case 1:
                push(stack, 5);
                break;
            case 2:
                pop(stack, 5);
                break;
            case 3:
                peek(stack, 5);
                break;        
            case 4:
                trav(stack, 5);
                break;        
            case 5:
                sort(stack);
                break;
            case 6:
                exit(0); 
            default:
                printf("INVALID INPUT");
                break;                
        }
    }
}  

</pre>
        <pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>

1 push():
2 pop ():
 3  peek ():
4 trav ()
5  sort ():
6  exit ():
Enter the choice : 1

Enter the item: 58
The item 58 inserted at index stack[0]
1 push():
2 pop ():
 3  peek ():
4 trav ()
5  sort ():
6  exit ():
Enter the choice : 1

Enter the item: 2
The item 2 inserted at index stack[1]
1 push():
2 pop ():
 3  peek ():
4 trav ()
5  sort ():
6  exit ():
Enter the choice : 1

Enter the item: 45
The item 45 inserted at index stack[2]
1 push():
2 pop ():
 3  peek ():
4 trav ()
5  sort ():
6  exit ():
Enter the choice : 1

Enter the item: 3
The item 3 inserted at index stack[3]
1 push():
2 pop ():
 3  peek ():
4 trav ()
5  sort ():
6  exit ():
Enter the choice : 1

Enter the item: 56
The item 56 inserted at index stack[4]
1 push():
2 pop ():
 3  peek ():
4 trav ()
5  sort ():
6  exit ():
Enter the choice : 1
!OVERFLOW
1 push():
2 pop ():
 3  peek ():
4 trav ()
5  sort ():
6  exit ():
Enter the choice : 5
Stack sorted in ascending order.

1 push():
2 pop ():
 3  peek ():
4 trav ()
5  sort ():
6  exit ():
Enter the choice : 4

 The elemensts present in stack are : 2 3 45 56 58
1 push():
2 pop ():
 3  peek ():
4 trav ()
5  sort ():
6  exit ():
Enter the choice :
</pre>

        <pre>
    <br>
<b id="stQ9">9. ENTER THE INFIX EXPRESSION FROM USER AND CONVERT INTO PREFIX EXPRESSION.</b>

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

struct stack 
{
    int max;
    char *array;
    int top;	
};

struct stack s1;
char infix[1000];
char prefix[1000];
int prefix_index = -1;

void init(int size) 
{
    s1.max = size;
    s1.array = (char *) malloc(sizeof(char) * s1.max);
    s1.top = -1;
}

void push(char item) 
{
    if (s1.top == s1.max - 1) 
    {
        printf("\nOverflow!");
        return;
    }
    s1.top++;
    s1.array[s1.top] = item;
}

char peek() 
{
    if (s1.top == -1) 
    {
        printf("\nEmpty Stack, cannot peek!");
        return '\0';
    }
    return s1.array[s1.top];
}

char pop() 
{
    if (s1.top == -1) 
    {
        printf("\nUnderflow!");
        return '\0';
    }
    return s1.array[s1.top--];
}

int precedence(char op) 
{
    if (op == '^') return 3;
    if (op == '*' || op == '/') return 2;
    if (op == '+' || op == '-') return 1;
    return 0;
}

void reverse(char *exp) 
{
    int n = strlen(exp);
    for (int i = 0; i &lt; n / 2; i++) 
    {
        char temp = exp[i];
        exp[i] = exp[n - i - 1];
        exp[n - i - 1] = temp;
    }
}

void convert() 
{
    reverse(infix);
    int i;
    char top_item;
    
    for (i = 0; infix[i] != '\0'; i++) 
    {
        if (isalnum(infix[i])) 
        {
            prefix[++prefix_index] = infix[i];
        } 
        else if (infix[i] == '+' || infix[i] == '-' || infix[i] == '*' || infix[i] == '/' || infix[i] == '^') 
        {
            while (s1.top != -1 && precedence(peek()) &gt; precedence(infix[i])) 
            {
                top_item = pop();
                prefix[++prefix_index] = top_item;
            }
            push(infix[i]);
        } 
        else if (infix[i] == ')') 
        {
            push(infix[i]);
        } 
        else if (infix[i] == '(') 
        {
            while (s1.top != -1 && peek() != ')') 
            {
                prefix[++prefix_index] = pop();
            }
            pop();
        }
    }
    
    while (s1.top != -1) 
    {
        prefix[++prefix_index] = pop();
    }
    
    prefix[prefix_index + 1] = '\0';
    reverse(prefix);
}

int main() 
{
    printf("Enter the infix expression: ");
    gets(infix);

    init(strlen(infix) + 2);
    convert();

    printf("Prefix expression: %s\n", prefix);
    free(s1.array);
    return 0;
}

</pre>
        <pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>
Enter the infix expression: (A*A(A^D(S+A))a+S*S-)
Prefix expression: -+*AA^AD+SAa*SS
</pre>

        <pre>
    <br>
<b id="stQ10">10. ENTER THE INFIX EXPRESSION FROM USER AND CONVERT INTO POSTFIX EXPRESSION.</b>

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
    
struct stack 
{
    int max;
    char *array;
    int top;	
};

struct stack s1;
char infix[1000];
char postfix[1000];
int postfix_index = -1;

void init(int size) 
{
    s1.max = size;
    s1.array = (char *) malloc(sizeof(char) * s1.max);
    s1.top = -1;
}

void push(char item) 
{
    if (s1.top == s1.max - 1) 
    {
        printf("\nOverflow!");
        return;
    }
    s1.top++;
    s1.array[s1.top] = item;
}

char peek() 
{
    if (s1.top == -1) 
    {
        printf("\nEmpty Stack, cannot peek!");
        return '\0';
    }
    return s1.array[s1.top];
}

char pop() 
{
    if (s1.top == -1) 
    {
        printf("\nUnderflow!");
        return '\0';
    }
    return s1.array[s1.top--];
}

void checkEndBrackets() 
{
    int x;
    if (infix[0] != '(') 
    {
        for (int i = strlen(infix); i &gt;= 0; i--) 
        {
            infix[i + 1] = infix[i];
        }
        infix[0] = '(';
    }
    if (infix[strlen(infix) - 1] != ')') 
    { 
        x = strlen(infix);
        infix[x] = ')';
        infix[x + 1] = '\0';
    }
}

void convert() 
{
    int i;
    char top_item;

    for (i = 0; infix[i] != '\0'; i++) 
    {
        if (infix[i] == '+' || infix[i] == '-' || infix[i] == '*' || infix[i] == '/' || infix[i] == '^') 
        {
            while (s1.top != -1 && (peek() == '^' || (peek() == '*' || peek() == '/') && 
            (infix[i] == '+' || infix[i] == '-')))
            {
                top_item = pop();
                postfix[++postfix_index] = top_item;
            }
            push(infix[i]);
        } 
        else if (infix[i] == '(') 
        {
            push(infix[i]);
        } 
        else if (infix[i] == ')') 
        {
            while (s1.top != -1 && peek() != '(') 
            {
                postfix[++postfix_index] = pop();
            }
            pop();
        } 
        else 
        {
            postfix[++postfix_index] = infix[i];
        }
    }

    while (s1.top != -1) 
    {
        postfix[++postfix_index] = pop();
    }

    postfix[postfix_index + 1] = '\0';
}

int main() 
{
    printf("Enter the infix expression: ");
    gets(infix);

    init(strlen(infix) + 2);
    checkEndBrackets();
    convert();

    printf("Postfix expression: %s\n", postfix);
    free(s1.array);
    return 0;
}


</pre>
        <pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>
Enter the infix expression: (a+(v^S)s+d*s)
Postfix expression: avS^sds*++
</pre>

        <pre>
    <br>
<b id="stQ11">11. CREATE A PROGRAM TO EVALUATE THE PREFIX EXPRESSION.</b>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;

struct stack 
{
    int max;
    double *array;
    int top;	
};

struct stack s1;
char infix[1000];
char prefix[1000];
int prefix_index = -1;

void init(int size) 
{
    s1.max = size;
    s1.array = (double *) malloc(sizeof(double) * s1.max);
    s1.top = -1;
}

void push(double item) 
{
    if (s1.top == s1.max - 1) 
    {
        printf("\nOverflow!");
        return;
    }
    s1.top++;
    s1.array[s1.top] = item;
}

double pop() 
{
    if (s1.top == -1) 
    {
        printf("\nUnderflow!");
        return 0;
    }
    return s1.array[s1.top--];
}

int isDigit(char c) 
{
    return c &gt;= '0' && c &lt;= '9';
}

double evaluatePrefix() 
{
    for (int i = prefix_index; i &gt;= 0; i--) 
    {
        if (isDigit(prefix[i])) 
        {
            push(prefix[i] - '0');
        } 
        else 
        {
            double operand1 = pop();
            double operand2 = pop();
            switch (prefix[i]) 
            {
                case '+': push(operand1 + operand2); break;
                case '-': push(operand1 - operand2); break;
                case '*': push(operand1 * operand2); break;
                case '/': push(operand1 / operand2); break;
                case '^': push(pow(operand1, operand2)); break;
            }
        }
    }
    return pop();
}

void reverse(char *exp) 
{
    int n = strlen(exp);
    for (int i = 0; i &lt; n / 2; i++) 
    {
        char temp = exp[i];
        exp[i] = exp[n - i - 1];
        exp[n - i - 1] = temp;
    }
}

int precedence(char op) 
{
    if (op == '^') return 3;
    if (op == '*' || op == '/') return 2;
    if (op == '+' || op == '-') return 1;
    return 0;
}

void convert() 
{
reverse(infix);
for (int i = 0; infix[i] != '\0'; i++) 
{
    if (isDigit(infix[i])) 
    {
        prefix[++prefix_index] = infix[i];
    } 
    else if (infix[i] == '+' || infix[i] == '-' || infix[i] == '*' || infix[i] == '/' || infix[i] == '^') 
    {
        while (s1.top != -1 && precedence(s1.array[s1.top]) &gt; precedence(infix[i])) 
        {
            prefix[++prefix_index] = pop();
        }
        push(infix[i]);
    } 
    else if (infix[i] == ')') 
    {
        push(infix[i]);
    } 
    else if (infix[i] == '(') 
    {
        while (s1.top != -1 && s1.array[s1.top] != ')') 
        {
            prefix[++prefix_index] = pop();
        }
        pop();
    }
    }
    
    while (s1.top != -1) 
    {
        prefix[++prefix_index] = pop();
    }
    
    prefix[prefix_index + 1] = '\0';
    reverse(prefix);
}

int main() 
{
    printf("Enter the infix expression: ");
    gets(infix);

    init(strlen(infix) + 2);
    convert();
    
    printf("Prefix expression: %s\n", prefix);
    double result = evaluatePrefix();
    printf("Evaluation result: %.2f\n", result);
    
    free(s1.array);
    return 0;
}

</pre>
        <pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>
Enter the infix expression: (8+4)*4
Prefix expression: *+844
Evaluation result: 48.00
</pre>

        <pre>
    <br>
<b id="stQ12">12. CREATE A PROGRAM TO EVALUATE THE POSTFIX EXPRESSION.</b>
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#define size_INT16_MAX_ 100

void push(int *stack, int *top, int val) 
{
    stack[++(*top)] = val;
}

int pop(int *stack, int *top) 
{
    return stack[(*top)--];
}

int peek(int *stack, int *top) 
{
    return stack[*top];
}

int main() 
{
    int size = size_INT16_MAX_;
    int top = -1;
    char exp[size];
    int stack[size];
    int result;
    char curr;
    int ind = 0;
    int opr1, opr2;
    int i;
    
    printf("ENTER A POSTFIX EXPRESSION : ");
    gets(exp);
    
    for (i = 0; exp[i] != 0; i++) 
    {
        if ((exp[i] == '^') || (exp[i] == '*') || (exp[i] == '/') || (exp[i] == '+') || (exp[i] == '-')) 
        {
            opr2 = (int)(pop(stack, &top)); 
            opr1 = (int)(pop(stack, &top)); 
            if (exp[i] == '^') 
            {
                push(stack, &top, pow(opr1, opr2));
            }
            if (exp[i] == '*') 
            {
                push(stack, &top, opr1 * opr2);
            }
            if (exp[i] == '/') 
            {
                push(stack, &top, opr1 / opr2);
            }
            if (exp[i] == '+') 
            {
                push(stack, &top, opr1 + opr2);
            }
            if (exp[i] == '-') 
            {
                push(stack, &top, opr1 - opr2);
            }
        } 
        else if ((exp[i] &gt; 47) && (exp[i] &lt; 58)) 
        {
            push(stack, &top, exp[i] - 48);
        }
    }
    
    result = pop(stack, &top);
    printf("RESULT : %d", result);
    return 0;
}

</pre>
        <pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>
ENTER A POSTFIX EXPRESSION : 23*
RESULT : 6
</pre>

        <pre>
    <br>
<b id="stQ13">13. IMPLEMENT THE TOWER OF HANOI USING STACKS.</b>

#include &lt;stdio.h&gt;
#define max 5
#define mid 4
#define min 3
void push(int *stack, int *top, int val)
{
stack[++(*top)] = val;
}
int pop(int *stack, int *top)
{
return stack[(*top)--];
}
int peek(int *stack, int *top)
{
return stack[*top];
}
static inline int isEmpty(int *stack, int *top)
{
return *top == -1;
}
static inline int isFull(int *stack, int *top, int level)
{
return *top == (level - 1);
}
int main()
{
int level;
int rodArray[3][max];
int topArray[] = {-1, -1, -1};
int discs;
int from;
int to;
printf("1.EASY\n2.MEDIUM\n3.HARD\nCHOOSE LEVEL: ");
scanf("%d", &level);
if (level == 1)
{
level = min;
}
else if (level == 2)
{
level = mid;
}
else if (level == 3)
{
level = max;
}
else
{
level = min;
}
for (int i = level; i &gt; 0; i--)
{
push(rodArray[0], &topArray[0], i);
}

while (1)
{
for (int j = 0; j &lt; 3; j++)
{
for (int k = topArray[j]; k &gt;= 0; k--)
{
    for (int i = 0; i &lt; rodArray[j][k]; i++)
    {
        printf("*");
    }
    printf("\n");
}
printf("------------------------------------\n");
}
printf("MOVE FROM (1/2/3) : ");
scanf("%d", &from);
printf("MOVE TO (1/2/3) : ");
scanf("%d", &to);
if (isEmpty(rodArray[from - 1], &topArray[from - 1]) || ((rodArray[from - 1][topArray[from - 1]] &gt;
rodArray[to - 1][topArray[to - 1]]) && (topArray[to - 1] != -1)))
{
printf("MOVE FAILED\n");
}
else
{
push(rodArray[to - 1], &topArray[to - 1],
        pop(rodArray[from - 1], &topArray[from - 1]));
}
}
}

</pre>
        <pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>

1.EASY
2.MEDIUM
3.HARD
CHOOSE LEVEL: 1
*****
------------------------------------
0
------------------------------------
0
------------------------------------
0
MOVE FROM (1/2/3) : 1
MOVE TO (2/3) : 2
*
------------------------------------
0
------------------------------------
*
------------------------------------
0
MOVE FROM (1/2/3) : 1
MOVE TO (2/3) : 3
MOVE FAILED

</pre>

    </div>



    <button class="back-to-top" id="backToTopBtn">Back to Top</button>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script>
        hljs.highlightAll();

        // Get the button
        const backToTopBtn = document.getElementById("backToTopBtn");

        // Show or hide the button based on scroll position
        window.onscroll = function () {
            if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
                backToTopBtn.style.display = "block";
            } else {
                backToTopBtn.style.display = "none";
            }
        };

        // Scroll to the top when the button is clicked
        backToTopBtn.onclick = function () {
            document.body.scrollTop = 0; // For Safari
            document.documentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
        };
    </script>
</body>

</html>